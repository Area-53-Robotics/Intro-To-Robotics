{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Robotics","text":"<p>First of all, welcome.</p> <p>Robotics is hard work. Reading these documents will give you a basis for understanding many of the things you will need to know. Like anything else, they are useless without application, and can only be refined with practice. With that said: nothing ever turns out how it is supposed to. This line carries so much weight the more you delve into robotics. I hope you\u2019ll never have to experience the full burden of that phrase. In fact, no one should. That\u2019s why you have a team.</p> <p>My first year in robotics, I was placed on a team with new and old friends. Our only downside was that we were new to everything. We had no seniors on our team, so we looked to seniors on other teams for guidance. Even though we learned much from them, we had to teach ourselves many of the things that would become beneficial to us. Our first year, we only went to 3 tournaments and our highest ranking was 22nd place. But, we considered this a success because we were able to build and program a working robot that completed the task at hand--albeit not very well. Our second year we won a tournament, qualifying for states and nationals. I write this now, looking into my third season and back at my first two, and realize that we became what freshman us needed to look up to and learn from. So, my friends and I have compiled our knowledge into these documents for you and any other newcomers who need this information.</p> <p>-- Julian Cooper Leader and Lead Builder of 53E, Class of 2022</p>"},{"location":"about-the-authors/","title":"About the Authors","text":""},{"location":"about-the-authors/#2020-graduates","title":"2020 Graduates","text":"<p>Teresa Thoundayil - ERHS 2020 graduate and Georgia Tech 2024 graduate. She was 53A\u2019s lead, builder, notebooker, and driver.</p>"},{"location":"about-the-authors/#2022-graduates","title":"2022 Graduates","text":"<p>Chad Bo - 53E\u2019s co-lead, notebooker and builder.</p> <p>Gavin Crisologo - 53C\u2019s co-lead and coder.</p> <p>Julian Cooper - 53E\u2019s lead and builder.</p> <p>Jan Lapira - 53E\u2019s driver.</p> <p>Austin Luu - 53C\u2019s lead and builder.</p> <p>Ben Schultz - 53B\u2019s lead and builder.</p> <p>Kevin Yen - 53A\u2019s lead, builder, and coder.</p>"},{"location":"about-the-authors/#2024-graduates","title":"2024 Graduates","text":"<p>Felix Hass - 53E's lead and coder.</p>"},{"location":"about-the-authors/#2025-graduates","title":"2025 Graduates","text":"<p>Alan Morales - 53E</p> <p>Veena Raj - 53A</p>"},{"location":"about-the-authors/#2026-graduates","title":"2026 Graduates","text":"<p>Isaiah Blanc - 53C</p>"},{"location":"driving/","title":"Driving","text":""},{"location":"driving/#drive-team","title":"Drive Team","text":"<p>Contrary to popular belief, the drive team is not there just to watch. In fact, the drive team actually bears the most responsibility during a match. As a drive team member, your job is to keep track of everything. And by everything, I do mean everything. You should know what your teammate is doing, what your opponents are doing, who is winning, who is losing, how much time is left, where your driver should go next to score, who is in a vulnerable position that you can take advantage of, and more. Drive team members should not solely watch their own robot, but instead watch the entire match and take stock of the entire game situation.</p> <p>One drive team member should stay focused on the time while also talking to the alliance partner\u2019s drive team. Effective communication within an alliance is important to winning. The other drive team member should be focused monitoring the whole game and telling the driver where to go. These are only general roles, which may change slightly depending on the game. For example, in Tower Takeover, one drive team member\u2019s job was always to keep track of the number of cubes of each color each alliance had to determine which color cubes to place in the tower to benefit their own alliance.</p>"},{"location":"driving/#driver","title":"Driver","text":"<p>The driver\u2019s only job is to drive the robot. However, this does not mean they do not need to know the game and its rules extremely well. Although the drive team should do their best to tell the driver the best course of action at all times, it is inevitable that the driver will have to make a split second decision in order to win. In a pinch, the driver should be able to fulfill either or both of the drive team member\u2019s jobs, but this is not ideal as it gives the driver too many things to focus on.</p>"},{"location":"driving/#practice","title":"Practice","text":"<p>There is no real way to teach someone how to drive. In my experience, the only way to learn to drive is to practice. Depending on the state of completion of your robot, practice can involve many different things. If your robot is only a drivetrain at this point, you can set up obstacle courses to complete or practice driving from point A to point B or simply practice driving to a certain spot and turning your bot to face a certain direction. If you have a mostly or fully completed bot, you should try doing full skills runs to practice your driver skills or play in scrimmages against other teams to get experience in match-like conditions. And if you can\u2019t drive your bot, try watching match videos or come up with new strategies to try.</p>"},{"location":"driving/#driving-in-a-match","title":"Driving in a Match","text":"<p>There\u2019s nothing really to say here except to remain calm and be adaptable.</p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#welcome","title":"Welcome","text":"<p>As a freshman, you\u2019ll need to learn new skills, and be able to execute them. As I\u2019ve said, my freshman year was not nearly as good as my sophomore year, but I learned many skills and lessons to prepare me. I\u2019m trying to include 3 things in this manual: General robotics knowledge, Stuff no one teaches you but expects you to do (like taxes), and Theory. You have to understand general robotics knowledge to be able to do anything. This includes everything in The Basics and everything except Leading in The Techniques. I would also include Resources here, but it contains links for all types of skills. Still check out Resources and know how to use the links. Next is the tax-like stuff. You should understand this to become a better teammate, and to understand how to handle situations. If you know how to properly handle situations, you\u2019re a very valuable person. These include Leading, and everything in The Season and The Tournament. Last, we have theory. This may be the worst part of this document because we get away from the robotics standpoint and approach the \u201cpolitical\u201d side of it. I\u2019ll elaborate more in the actual section, but Theory teaches you how to lead and change the entire club. Take everything I say as a guideline; always put your own spin on these to better conform to your environment. Other than that, I can only give you my best.</p>"},{"location":"introduction/#being-a-good-teammate","title":"Being a Good Teammate","text":"<p>A good teammate has valuable robotics skills, but is also generally a good person. We\u2019ll start on robotics skills, which I\u2019ll elaborate more on in The Techniques. Each person has their own job. Each person should be the best person, or close to the best, for that job. If you know how to navigate your job well, and solve problems within your job, you have valuable robotics skills. But, let\u2019s say that you have the best person for each role. All of them hate each other. This team won\u2019t work as each person can\u2019t be a good person to each other. If you have a team with people that can work well together, no matter the robotics skill, they will be a good team and if not they\u2019ll at least have fun. To close, be a nice person to your teammates. You should have different opinions and ideas, but you should also resolve the differences healthily. Robotics will get heated, but if your team can solve the problem using logic, you\u2019ll turn out on top.</p>"},{"location":"leading/","title":"Leading","text":"<p>The leader of a team isn\u2019t just the leader. They\u2019re a builder, coder, or driver, and they don\u2019t even have to be the best. The leader\u2019s job has nothing to do with the robot, rather, it has everything to do with your teammates. I do want to say that all leaders are different, so there will be some practices that I implement that you don\u2019t agree with. The differences arise in how your team functions and each person\u2019s personality.</p>"},{"location":"leading/#meetings","title":"Meetings","text":"<p>As the leader, your job is to direct each meeting so that your teammates stay on track and current goals are completed. Your meetings will change as your season progresses because your goals change. For example in the beginning of the season, your goal is to get the robot built, while at the end of the season you may prioritize driving. Below is a generalized meeting:</p>"},{"location":"leading/#pre-meeting","title":"Pre-Meeting","text":"<p>Go into the meeting prepared with what you want to accomplish. Maybe today\u2019s the day you build the drivetrain, maybe you practice auton. Have your meeting thought out a day or two in advance. It doesn\u2019t have to be super thorough, although a checklist could help here. You may not finish all the tasks you want to during a meeting, this is normal, just make sure that you can finish all the tasks you want to before the time that they\u2019re relevant (e.g. a tournament).</p>"},{"location":"leading/#start-of-the-meeting","title":"Start of the Meeting","text":"<p>The most important part about the beginning is getting people organized. Many times people will be late for various reasons so make sure you can cover them or ensure that they\u2019re early. You should try and get your teammates working as soon as possible, this includes you. If you have a task you need to start, start it. If you need to get someone else\u2019s task started (pulling out the robot and relevant parts), do so as it will help get people moving as they come in. Once everyone is there, fill them in on the goals. It\u2019s always nice to have people stand around a table and have a concise plan laid out. This is also a good time to let your team be aware of any important news that comes up. This may also be the only time you can talk to your entire team at once with their attention, so if you need to say anything do it now.</p>"},{"location":"leading/#middle-of-the-meeting","title":"Middle of the Meeting","text":"<p>Your team should break to complete whatever goals you have laid out. For example, the lead builder will talk to the secondary builder(s) about what needs to be built and how they\u2019ll do it. Many times, especially later in the season, you will have goals that need to be completed after another goal. If you can, try to keep people active within your team. If you\u2019re practicing auton and your builders have nothing to do, have them reset the field. If you have no jobs for people, send them to help out another team. Everyone appreciates an extra set of hands. Remember, busywork is still a job, inactive people can at least do that. Also, try to be active in each activity. Check in on the robot\u2019s progress, check in on how the code\u2019s coming, check in on the last skills run, check in so you stay up to date with your team. This will also help you evaluate goals.</p>"},{"location":"leading/#end-of-the-meeting","title":"End of the Meeting","text":"<p>After you\u2019ve finished an amount of goals, you need to wrap up. This can be anywhere from 15 minutes from the end to an hour past. The worst part about the meeting is having to clean up. Have your entire team clean up so that your workspace will be nice for your next meeting. Organize your parts so that you and your sister teams can find them.</p>"},{"location":"leading/#post-meeting","title":"Post-Meeting","text":"<p>After each meeting, in the car ride home, reflect over what happened in the meeting. What was actually completed? What was partially completed? What wasn\u2019t completed? If something was completed, move on to the next objective. If something wasn\u2019t completed or completed fully, finish it, then move on. If something doesn\u2019t get completed, you can\u2019t blame anyone. Maybe a previous goal took longer than expected. Maybe you set too many goals. The only time you can blame someone is if they weren\u2019t doing anything and even then you shouldn\u2019t. Once you\u2019ve determined what happened at the meeting, go back to Pre-meeting. It never ends.</p>"},{"location":"leading/#season-timing","title":"Season Timing","text":"<p>As the leader, you\u2019re also responsible to lead your team through a season. Basically, you need to have a coded, driven, functioning robot before a tournament. How do you get there? Let\u2019s start with the beginning of the season, we\u2019ll cover a bit more of this in The Season.</p>"},{"location":"leading/#the-beginning","title":"The Beginning","text":"<p>You want to lead your team through learning the new game. The Season talks about the pre-reveal and the reveal. Lead your team through these so that you\u2019re all on the same page and everyone understands what needs to be understood. In the very beginning of the season, specific roles don\u2019t matter too much. Notebooking is very important, so ensure that your notebooker is doing their job. Once your team has a general idea of what you\u2019re going to do, you move into the middle season.</p>"},{"location":"leading/#the-middle","title":"The Middle","text":"<p>You are not the lead builder, lead coder, or lead driver (unless you are). You do not have domain over exactly how something should be built. That\u2019s the lead builder\u2019s job. Give your suggestions, they\u2019re important, but you can\u2019t use your leader position to control how other people work.</p> <p>Once you have a design decided on, tell your lead builder to talk people through how to build the robot. Ask them to give you relevant goals to accomplish in meetings. The same goes for your coders and drivers. You want to let your lead builder/coder/driver decide what direction to take the robot. You decide how to make sure your team follows their directions.</p> <p>But, you may also have to make executive decisions. Maybe people are having a disagreement, you might be the tiebreaker. Make sure to think through your decision. Maybe there\u2019s no code written for your robot 3 weeks before a tournament. Start coding. You can go to a tournament with an incomplete robot, you can\u2019t go without good code.</p> <p>What\u2019s a good timeline? Build a part. Code whatever part you can once it\u2019s built. Test it after it\u2019s coded. Keep doing that until you have a robot. You\u2019ll have to talk to your lead builder/coder/driver to get a feel for when something will be done. Building always initially take the longest, although tapers off at the end. Coding can initially be very short, although it will get more tedious later. Driving is usually tied to coding, that\u2019s still true here. Your first tournament won\u2019t be your best. Make sure you have a functioning robot going into it. It doesn\u2019t have to do everything, as long as it can drive you\u2019re good. Two weeks before your first tournament you want to have your robot coded and your driver driven it. One week before, you want to have a simple auton coded, this isn\u2019t necessary although it will help you a lot. You will also want more driving practice and building fixes. The meeting before the tournament should be minor tweaks, driving practice, and auton practice. Make sure your team is prepared for the tournament, don\u2019t set them up for failure. Keep goals on time and make calls if they aren\u2019t.</p>"},{"location":"leading/#in-between-tournaments","title":"In-Between Tournaments","text":"<p>I\u2019m going over tournaments in the next section. Depending on the time between tournaments, you can improve on a number of things. I recommend going over what went well and what didn\u2019t at your first meeting back or if you don\u2019t have time, talk to your teammates about it and make some decisions. Either way, decide what goals you need to accomplish before your next tournament. Knock them out. Before the next tournament, make sure your driver gets practice.</p> <p>End of the Season These are your last qualifying tournaments and any final tournaments. No major building changes. I can\u2019t tell you to follow that strictly, but try not to change your build. Your driver has had the entire season to learn the robot, they\u2019ll have a few weeks to learn a new one. What you do want to change is code, whether it\u2019s a better function or it\u2019s a better auton. You also want more driving practice, more skills practice, and more in-club scrimmages. You\u2019re late game now, it\u2019s not the time to recreate your robot, it\u2019s the time to take what you have and compete. Make sure your team follows your instructions on this explicitly.</p>"},{"location":"leading/#tournaments","title":"Tournaments","text":"<p>Similar to the rest of the time, your job as leader during a tournament is to pull your team through. Unlike the rest of the season, your word is final.</p>"},{"location":"leading/#pre-tournament-prep","title":"Pre-Tournament Prep","text":"<p>Make sure your driver has practiced, your code is finished, and your robot is good. Pack any parts you think you\u2019ll need and any parts you might not. Keep your team in good spirits and make sure everyone feels ready for the tournament (no one really feels ready, although you have to accept you\u2019ve done everything you can). You also have to ensure that everyone has rides to the tournament.</p>"},{"location":"leading/#pre-matches","title":"Pre-Matches","text":"<p>When you get to the tournament, get everyone ready and get your driver practicing or get your auton practiced. Have someone check-in and give the judges your notebook. When you have everyone together, excluding your driver, give them their assignments. You\u2019ll need at least one person scouting and watching all the matches, don\u2019t make this yourself because you need to be there for your team. You\u2019ll need up to 2 people to be the drive team, your driver will pick them. Any other people will need to standby for coding changes and building fixes. Your driver will be driving. They are the key to the tournament, it\u2019s your job to give them the best chance at winning. Get ready for your matches, make sure everyone has the schedule, don\u2019t break your robot.</p>"},{"location":"leading/#qualification-matches","title":"Qualification Matches","text":"<p>Get your team to each match on time. In-between matches, practice your auton, practice your driving, fix minor parts. But, don\u2019t overdo it, you want people to be fresh. This is everyone\u2019s time for a break, take it. During the match cheer or don\u2019t cheer, I\u2019m not sure what your driver likes. Again, cater to your driver. Sometime during the tournament, you will be judged. Make sure you are judged in-between matches, you want everyone there to talk. Judging will be covered more in The Tournament. Also during your time off you should complete skills. Only do this when your driver is ready. It is your job to get your team to skills. Know your schedule so you can find a good opening to do skills and judging.</p> <p>Most importantly, you will have to make decisions on everything in the tournament. Will you let your builder change this part? Do you want to go with code 1 or code 2? What partner will you choose? You should talk to the respective leads and your driver about what they want done. Once you make your decision based off of theirs, it\u2019s final. No one argues with it. Use a stern voice. Remember: you have to get your team through a tournament no matter how much somebody wants to do X, Y and Z.</p>"},{"location":"leading/#finals","title":"Finals","text":"<p>You\u2019ll have to pick partners. Use your scout\u2019s information and talk with your teammates. Ultimately it\u2019s your driver\u2019s decision. If they don\u2019t know, it\u2019s your\u2019s and your scout\u2019s. Get your team and your partner\u2019s to matches on time. Offer to help with anything they need. They are an extension of your team. You should know of and use a timeout. Each pair only gets 1 timeout in all of the finals matches. But, if you need to get that last auton made, it might be worth it. Each timeout is 3 minutes. Eventually, you\u2019ll get to your match and you want to support your team. Do whatever is best for your driver. This is when it matters.</p>"},{"location":"leading/#conclusion","title":"Conclusion","text":"<p>Your job is to get your team through the season. Whether it\u2019s a meeting or a tournament, your job is to advance your team. Listen to your teammates for information and make judgments. Sometimes you\u2019ll be right, sometimes you\u2019ll be wrong. A good leader will know how to correct the wrongs (listen to the leads). What is your short-term end goal? Build a drivetrain? Finish the code? Do driving practice? Get through the tournament? Make sure your team knows, and make sure you follow steps to accomplish the goal.</p>"},{"location":"notebooking/","title":"Notebooking","text":"<p>I can\u2019t notebook. I can barely read my own handwriting. I\u2019ll turn it over to our best notebookers: Terry from 53A and Chad from 53E. Terry\u2019s notebooks have won numerous awards, he\u2019s the real deal. What is notebooking and documentation? Quoted from Wikipedia (it's a good source despite what school tells you, trust me), documentation is \u201ccommunicable material that is used to describe, explain or instruct regarding some attributes of an object, system or procedure, such as its parts, assembly, installation, maintenance, and use.\u201d Simply put, you are showing the process taken to reach your final product, simple as that. It\u2019s hard at first, it\u2019s time-consuming, however as we shall explain later, it is very important and applicable not only to VEX, but also in your future careers.</p> <p>Notebooking in VEX is especially important since it is key to several important awards:</p> <ul> <li>The Design Award</li> <li>The Excellence Award</li> <li>To reach these, your notebook needs to:</li> <li>Highlight what your robot is</li> <li>Prove that you built it</li> <li>Dive into the details of how you built it.</li> <li>Detail how you improved over time</li> </ul> <p>Teresa has compiled a slideshow for use alongside this section.</p>"},{"location":"notebooking/#basic-rules","title":"Basic Rules","text":"<p>(Slides 2-5) You\u2019ll need to follow some basics.</p> <ul> <li>Must be written in blue or black ink</li> <li>No typing!</li> <li>If you have the time, as often as possible type an entry, edit it, and then transcribe it.</li> <li>No white-out</li> <li>Accept your mistakes, don\u2019t edit your entries to look better.</li> <li>If you write the wrong word, draw a single line through it and continue</li> <li>If it\u2019s more than 5 words, sign the error</li> <li>Plan out your sentences so this doesn\u2019t happen</li> <li>Plan out large titles on other papers</li> <li>Don\u2019t cover words with photos, you\u2019ll lose points</li> <li>Each page is signed and initialed by writer and a witness</li> <li>Notes are in chronological order and dated</li> <li>You can\u2019t glue/tape in entries</li> <li>You can glue/tape in photos or drawings</li> </ul> <p>You\u2019ll also need to spread the work around. Writing is a lot of work. Each person should be contributing to entries, whether it\u2019s through an online document, writing rough drafts, or coming up with ideas or topics to write about. Contributing to notes is also key here.</p> <p>Your best artists should also do drawings. Drawings are real eye-catchers so they should be good, we\u2019ll talk more in-depth about drawing later. Only 1 person should be writing in the notebook, but there should be a system of other people helping that person out with obtaining material to write about. Optimally, people write into an online document, it\u2019s edited, and then transcribed. But, if you have to go straight to transcribing (you\u2019ll want to do it fast so you don't forget the information).</p>"},{"location":"notebooking/#first-pages","title":"First Pages","text":"<p>(Slides 6-10) Before we talk about content, we should tell you how your notebook is organized. Depending on the notebook you have, your Table of Contents or Profile will be first. Next, you talk about this year\u2019s game. Lastly, you talk about meetings and tournaments, they\u2019ll be in the next sections. Your first pages give the judges their first impression about your notebook (besides the cover). Make sure these look the way you want them to and contain all the right information.</p>"},{"location":"notebooking/#profile","title":"Profile","text":"<p>Your profile is when you introduce your team. You can add pictures of your team members and provide a more detailed introduction on who they are (keep this simple, 1-2 sentences max). Remember, this part is all about your team, not about your robot. If you really want to stand out to judges, you should place a key in this area. There are 2 color-coded keys. One to denote team members, the other to denote notebook topics. The second is sticky note tabs. These help improve organization and make the layout seem standardized.</p>"},{"location":"notebooking/#table-of-contents","title":"Table of Contents","text":"<p>Your table of contents breaks down your notebook. It\u2019s used to make it easier to find information and can show a brief overview of what you\u2019ve done.</p>"},{"location":"notebooking/#pre-reveal-reflection","title":"Pre-Reveal Reflection","text":"<p>Your pre-reveal reflection talks about what went well and what didn\u2019t in your previous season. This is an important discussion to have as it will help you grow as a team.</p>"},{"location":"notebooking/#rubric-requirements","title":"Rubric Requirements","text":"<p>(Slides 11-19) This is what gives you points, make sure you have them. This section details an important process, known as the engineering design process (sometimes abbreviated EDP). In the slideshow, please use page 1 of the design award rubric so you know everything judges are looking for in a notebook.</p>"},{"location":"notebooking/#game-rules","title":"Game Rules","text":"<p>This will be a fairly long and colorful entry. Make sure to note all rules relevant to this game. Having drawings of the field and game elements can be handy as they\u2019re useful for reference.</p>"},{"location":"notebooking/#brainstorming","title":"Brainstorming","text":"<p>Any type of project needs to be brainstormed. Break down each main section of your robot and record pros and cons. Go in-depth into what each part does and how it affects the whole design. The more quality ideas you have here, the better. Use your previous knowledge, what you\u2019ve viewed when other people used the design, or even build the design, to know how a design works (any takeaways). Judges notice new and innovative ideas, so don't be afraid to put something in even if it seems outlandish or out of the box. It is usually these ideas that really improve the quality of your robot and make you stand out as a great team.</p>"},{"location":"notebooking/#design-selection","title":"Design Selection","text":"<p>You\u2019ll need to select your top 1 or 2 designs so that you have something to fall back on. There are multiple ways to decide.</p> <ul> <li>Democracy - Each person votes for the best design</li> <li>Rank the Designs - Each person ranks all the designs and assigns points to them. When totaled, whichever has the most is chosen</li> <li>Lead - Either the leader or lead builder chooses what they think is best</li> <li>Scoring - The entire team assigns a point value to each design, the highest is chosen</li> <li>Assigning points can be a great way to see the strengths and weaknesses of a design from several different viewpoints (Example: Mobility, Speed, Power, etc)</li> </ul>"},{"location":"notebooking/#building-and-coding","title":"Building and Coding","text":"<p>This will take a large portion of your season and your early meetings. Record this chronologically.</p>"},{"location":"notebooking/#building","title":"Building","text":"<p>Make sure to create a design plan, sketches, commentary on progress, pictures, and any other things that help document the entire process of how you got from start to finish. You\u2019ll want to note what went well, but also what didn\u2019t. How you fix these issues is important. Occasionally, you\u2019ll need to rebuild a subsystem or even the entire robot. You can redo your entire brainstorming session, or look at your previous results. Make sure to record your reasons for rebuilding, how you did it, and what the results were.</p>"},{"location":"notebooking/#coding","title":"Coding","text":"<p>Make sure to take screenshots of code, and especially unique code. By having a special program or coding section, this can really be a great way to stand out to judges who are looking for something different than the rest of the teams. For auton runs, record data and paths taken into the notebook. This will allow judges to see what you did and allow you to improve among these runs. Be sure to show drivetrain code and describe how your drivetrain works. Other subsystems should also be highlighted. You can even draw a controller to show what happens when you press this button. Sensors can improve your robot, and depending on how you write them up, can improve your notebook. Note how the coder coded the sensor, implemented it, and what the difference would be if you didn\u2019t have the sensor.</p>"},{"location":"notebooking/#driving","title":"Driving","text":"<p>There are many times where your driver will have to pick up the controller. They\u2019ll all fall under this category and your notebook should reference all of them.</p>"},{"location":"notebooking/#testing","title":"Testing","text":"<p>After fixing a part or changing the code, you\u2019ll want to see how the robot reacts. Note the change and then have your driver test it a few times. Note the results, quantitative or qualitative. You can also set hypotheses and goals to try and get to a certain point. Note these and any improvements.</p>"},{"location":"notebooking/#practice","title":"Practice","text":"<p>Sometimes your driver just needs seat-time. You can make a point of it to time them to score X amount of points or score an amount of points in X time. These are good quantitative results. You can also discuss different driving strategies. Maybe you\u2019ve noticed that you score your points very fast. This may lead you to play more defense if you know you can score points without much time. If you can\u2019t score fast, maybe you can\u2019t play defense. Maybe you\u2019ve noticed that when you do X your robot responds Y. Depending on what it is, you may have to build a strategy around it or correct it. These are important qualitative results. This will also help your driver know how to improve.</p>"},{"location":"notebooking/#skills","title":"Skills","text":"<p>1 minute, score as many points as you can. Do lots of tests, especially if you prioritize skills during tournaments. Record different tests, their scores, and recent modifications that happened. You might also need to record changes to driving strategies or the robot itself during skills. For example, my team removed a part of our robot for skills so we could complete different objectives. With practice, you\u2019ll find what\u2019s optimal.</p>"},{"location":"notebooking/#other-requirements","title":"Other Requirements","text":"<p>Make sure you repeat your building, coding, and driving/testing so that you can improve your robot. Besides being necessary for a good robot, you need to document these changes for a good notebook. You and other teams should also be able to repeat any changes that you made, even building an exact copy of the entire robot just by reading your notebook. Make it detailed and organized! Buy your notebook first, don\u2019t bind it. Be thorough with the projects you show. Make sure to write each of them out and include them in your table of contents.</p>"},{"location":"notebooking/#extra-entries","title":"Extra Entries","text":"<p>(Slides 20-35) There are some important entries you should make that aren\u2019t necessarily part of the rubric, although they\u2019re necessary to have to compete for awards (but they will greatly increase your chances to get one).</p>"},{"location":"notebooking/#tournaments","title":"Tournaments","text":"<p>Tournaments are what makes robotics. They can also make your notebook. Try to write these entries as soon as possible since you have the memory fresh in your mind.</p>"},{"location":"notebooking/#reflection","title":"Reflection","text":"<p>An overall breakdown of the day. Talk about the tournament and how you did. Anything that was outstanding, good or bad, should be said here.</p>"},{"location":"notebooking/#match-analysis","title":"Match Analysis","text":"<p>This is when you can compare how your robot did in practice vs in theory. Start off with any strategies that you planned. Then talk about the match itself. Make sure to say why you won or lost, whether it be driving skills, robot quality, autonomous, or even luck. Although don\u2019t rely on luck too much. Don't forget to include your scores.</p>"},{"location":"notebooking/#addressing-problems","title":"Addressing Problems","text":"<p>Have each person say what they thought went wrong. Many times, this will be connected to your match analysis. Sometimes you have to make a fix in-between matches, include that problem here and the solution in the next section. Here you may also want to mention subsystems that underperformed, or didn\u2019t perform how you thought they would.</p>"},{"location":"notebooking/#planning-changes","title":"Planning Changes","text":"<p>Suggest new solutions to the problems you\u2019ve mentioned. Make sure to think of short-term fixes if you don\u2019t have time. If you do have time, do the long-term fix. You may also want to include different things other teams did, if they outperformed your robot. Other teams\u2019 robots can always be starting points as a reference for improvement.</p>"},{"location":"notebooking/#long-term-plans","title":"Long Term Plans","text":"<p>Write about what you need to do and how many meetings it will take. You may not have enough meetings to do everything so you\u2019ll have to explain that you chose the most important. Talk about what you\u2019re going to fix, this could go in its own entry.</p>"},{"location":"notebooking/#drawing","title":"Drawing","text":"<p>Drawings are really important because they highlight your notebook. A good drawing can explain a system better than words can. Use a ruler for these as you\u2019ll want straight lines, it goes a long way in helping your drawings look professional. You may also want to use colored pencils or pens. Don\u2019t mess up your drawings, so you may want to practice it on a separate piece of paper first. When you do mess up, try to correct it as much as you can or distinguish the error. Don\u2019t cover up drawings, although if you need to break the rules, don\u2019t let it be found.</p>"},{"location":"notebooking/#photography","title":"Photography","text":"<p>Photos are your primary source for showing off your robot. Be sure to use them well. Take pictures as you build so that judges can see the chronological flow from how you started to the finished product. Also take multiple pictures so that you can choose the best one. You\u2019ll have to stage your photos a bit, so keep that in mind. Make sure to get sharp and clear photos that have good lighting. When printing them out, it is recommended to use the schools\u2019 printers since they can produce very vibrant pictures (seeing it firsthand, there is a noticeable difference)</p>"},{"location":"notebooking/#code-inclusion","title":"Code Inclusion","text":"<p>Code is really important to add since it shows that you\u2019re actually programming your robot. You\u2019ll want to add screenshots as soon as you have them. You may even want to add pseudocode before you start coding. Make sure you show any edits to your code and any unique parts that you have.</p>"},{"location":"notebooking/#digital-notebooking","title":"Digital Notebooking","text":""},{"location":"notebooking/#final-tips","title":"Final Tips","text":"<p>(Slides 36-37) Keep improving, good luck!</p>"},{"location":"recommended-reading-order/","title":"Recommended Reading Order","text":"<p>Different people need to read different parts of this manual at different times. When you transfer into a new position, we suggest reading the corresponding section.</p>"},{"location":"recommended-reading-order/#freshman-year","title":"Freshman Year","text":"<ul> <li>Introduction</li> <li>The Basics</li> <li>Builders: Hardware</li> <li>Coders: Software</li> <li>Drivers: Driving Techniques</li> <li>Notebookers: Notebooking Techniques</li> <li>The Season</li> <li>The Tournament</li> </ul> <p>In your freshman year, you aren\u2019t expected to be the lead builder, lead coder, lead driver, or lead notebooker, but if you\u2019re looking into it, you should start learning. Your freshman year is also about making mistakes in order to improve. You aren\u2019t expected to lead your team through a season or a tournament, but you are expected to learn, so that you will have the experience and confidence to lead when you are older. Don\u2019t be afraid to make mistakes and ask questions, it\u2019s more important that you build your knowledge through practice.</p>"},{"location":"recommended-reading-order/#junior-year","title":"Junior Year","text":"<ul> <li>Leaders: Leading Techniques</li> <li>Club Leaders: Theory</li> </ul> <p>In your junior year, one member of your team should probably be taking the leading role. They\u2019re big shoes to fill - leaders need to have a grasp of all aspects of robotics and need to be able to guide and empower their team. Read Leading Techniques. Many times, devoted members want to restructure the club because they don\u2019t like X, Y, and Z. These people don\u2019t have to be the leaders of teams, but a large group of devoted members will be able to make positive changes. Read Theory.</p>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#links-and-videos","title":"Links and Videos","text":"<ul> <li>Vex CAD Discord</li> </ul>"},{"location":"resources/#parts","title":"Parts","text":"<ul> <li>Structure Video</li> <li>Motion Video</li> <li>Hardware Video</li> <li>Electronics Video</li> <li>VEX Sensors</li> <li>Building Ratchets</li> <li>Ratchet Examples</li> </ul>"},{"location":"resources/#subsystems","title":"Subsystems","text":"<ul> <li>Drivetrain Video</li> <li>Lift Video</li> <li>Cascade Video</li> <li>Intake Video</li> <li>Shooting Video</li> </ul>"},{"location":"resources/#hardware","title":"Hardware","text":"<ul> <li>Stationary Video</li> <li>Moving Video 1</li> <li>Moving Video 2</li> <li>Drivetrain Video</li> <li>AURA - X-Drive Explanation</li> </ul>"},{"location":"resources/#software","title":"Software","text":"<ul> <li>Lesson 1</li> <li>Lesson 1 Code File</li> <li>Lesson 2</li> <li>Lesson 2 Code File</li> <li>53A/C Code Explanations</li> <li>Operators - C++ Tutorials</li> <li>Simple control structures - C++ Tutorials</li> <li>Functions - C++ Tutorials</li> <li>Pros Documentatin</li> <li>Git Documentation</li> </ul>"},{"location":"resources/#code-quality","title":"Code Quality","text":"<ul> <li>Core C++ Naming Conventions</li> <li>Google naming conventions</li> <li>Commenting Guide</li> </ul>"},{"location":"resources/#libraries-for-pros","title":"Libraries for PROS","text":"<ul> <li>Okapilib</li> <li>ARMS</li> <li>Lib4253</li> <li>Sylib</li> <li>EZ Template</li> <li>LemLib</li> </ul>"},{"location":"resources/#high-quality-robot-code","title":"High Quality Robot Code","text":"<ul> <li>lib7842</li> <li>4253B-Tipping-Point-Worlds</li> <li>nickmertin/5225A-2017-2018</li> <li>Team_7K_robotics</li> </ul>"},{"location":"resources/#notebooking","title":"Notebooking","text":"<ul> <li>Teresa\u2019s Notebook Guide</li> </ul>"},{"location":"resources/#the-tournament","title":"The Tournament","text":"<ul> <li>VRC Hub</li> <li>VEX Via</li> <li>Teresa\u2019s Judging Guide</li> <li>Judge Guide</li> <li>Design Rubric</li> <li>Interview Rubric</li> </ul>"},{"location":"resources/#theory","title":"Theory","text":"<ul> <li>The Area 53 Team Division Manifesto</li> </ul>"},{"location":"resources/#misc","title":"Misc","text":"<ul> <li>Sigbots Wiki</li> <li>Fusion 360 Add-In</li> <li>Team Standings</li> </ul>"},{"location":"the-season/","title":"The Season","text":"<p>Dun, dun, dun. Out of the two parts of robotics (meetings and tournaments), this is the second best! We\u2019re going to take all of what you learned previously and bundle it into an entire season. Use common sense and logic. I\u2019d say that there\u2019s as much thinking through problems as there is applying the previously taught material. This section is divided into 4 sections designed to mimic the natural progression of a season. If you learn this with a team, your senior members will do this out of habit, although there are some tricks that they might not know. If you don\u2019t learn this with a team, try to find people to bounce ideas off of since all activities work better with collaboration. If you\u2019re with a team but you don\u2019t have any seniors to help you, follow this guide to learn the ins and outs.</p>"},{"location":"the-season/#pre-reveal","title":"Pre-Reveal","text":"<p>This is a very boring but very important part of the brainstorming season. For new members this step is impossible to do, although it helps to listen to senior members. Get ready to start the season.</p>"},{"location":"the-season/#lessons-learned","title":"Lessons Learned","text":"<p>Last season we did this but didn\u2019t do that. We saw other teams do this when we did that. We did this and other teams did this too. The first thing you want to do when approaching a season is reflect on your past season. Here\u2019s a list of pros and cons of things you\u2019ll want to consider:</p> <ul> <li>Building</li> <li>Coding</li> <li>Driving</li> <li>Tournaments</li> </ul> <p>Make sure to think of good and bad things that happened regarding each of these and think of what you as a team can do to improve. Your leader should take your team through this exercise and ensure that your team is able to grow. Your notebooker should take notes on what you discussed, and then organize it into a write-up that shows progression. Everyone should talk about what they saw, even if they aren\u2019t the lead person of that role (i.e. a coder can talk about building, even if they aren\u2019t the lead builder). Lead persons should take special consideration into what they saw in how people worked together in the respective role and how they will lead their role better.</p> <p>In this section you may also want to consider non-robotics issues such as:</p> <ul> <li>Inter-team interactions</li> <li>Intra-team interactions</li> <li>Coach and parent interactions</li> </ul> <p>Also think about how you worked as a team. These things could be interesting to talk about if you want to tear each other's throats out. Think about things that you and others did well or didn\u2019t do well. This will either lead to a better team or different teammates, both are improvements. Anything that you think needs to be said should probably be said. This is the time to get everything off your chest.</p>"},{"location":"the-season/#meetings","title":"Meetings","text":"<p>Since this is the beginning of the season, it\u2019s also a good time to plan out meetings. See what day you all will be able to make a meeting. I like having 2 meetings a week although many times we can only get 1. At this time you should also plan your next few meetings which include:</p> <ul> <li>Watch parties for the reveal</li> <li>Reveal discussion</li> <li>Post-reveal discussion</li> </ul> <p>We\u2019ll go more in-depth later, but make sure to have meetings set up since these next few meetings determine a lot of what you do for the rest of the season.</p>"},{"location":"the-season/#reveal","title":"Reveal","text":"<p>The most fun part of your brainstorming season. Get a bunch of friends together, watch some live stream, yell at said live stream, cry that the game is so bad, then start designing the best robots this side of the Mississippi has ever seen while mumbling under your breath \u201cthis game sucks.\u201d Got a bit too realistic there.</p>"},{"location":"the-season/#watch-parties","title":"Watch Parties","text":"<p>Watch parties are lots of fun and really important. Work with other teams for this as more input is better. Many times, most of the club will get together and participate. Other times we send someone to spy on the state server to hear ideas. Some teams even stream their watch parties. I\u2019ll go through the steps of a watch party.</p>"},{"location":"the-season/#get-together","title":"Get Together","text":"<p>Have someone organize the watch party. VEX says when they will do the live stream of the new game, so planning around that is important. If you aren\u2019t able to make the specified time, you can still participate afterwards.</p>"},{"location":"the-season/#watch-it","title":"Watch It","text":"<p>Get together in person or on social media, and gather a bunch of materials (below). Watch the VEX live stream. Bring some snacks too, pretzels are always nice because there\u2019s no dust left on any papers you bring. Materials:</p> <ul> <li>Phone and laptop</li> <li>Printer and graph paper (about 5 of each per person)</li> </ul> <p>Your notebooker should also take notes about what happened during the watch party. If your team has taken notes about the game, they\u2019ll be grateful.</p>"},{"location":"the-season/#understand-the-game","title":"Understand the Game","text":"<p>After you watch the game, you\u2019ll want to dive right into designing your robot. But, it\u2019s important that everyone understands the game first. Things to do to understand the game:</p> <ul> <li>Watch the video multiple times<ul> <li>Think about the important parts, there\u2019s a lot of fluff in the videos</li> </ul> </li> <li>Read the game manual     -It\u2019ll be on the VEX website<ul> <li>It\u2019s a very long document, but you should learn the rules in it</li> </ul> </li> <li>Explain the game to others<ul> <li>Teaching others will help you understand the game better too</li> </ul> </li> </ul> <p>You should understand the game to see what your robot can and can\u2019t do. Your notebooker should also understand the game as writing up the game is an important part of the notebook.</p>"},{"location":"the-season/#post-reveal","title":"Post-Reveal","text":"<p>This is where robotics really starts. Your team should still be together, and this should occur right after you\u2019ve watched the reveal. Another suggestion is for each person to create their own ideas for each bolded section then come together and share. Put your bad ideas cap on because we want every single one of them. For legal reasons, that was a joke, please give good ideas.</p>"},{"location":"the-season/#identifying-objectives","title":"Identifying Objectives","text":"<p>You\u2019ve watched the reveal and you understand the game semi-perfectly. First you need to break the game down. Identify these or more:</p> <ul> <li>Offensive strategies</li> <li>Defensive strategies</li> <li>Scoring strategies</li> <li>Descoring strategies</li> </ul> <p>Make sure each person understands each strategy. Everyone should also be thinking about how these strategies play into building, coding, and driving the robot.</p>"},{"location":"the-season/#solving-objectives","title":"Solving Objectives","text":"<p>This is a very long section. This is your brainstorming section for notebookers. There are a lot of different categories to discuss and a lot of ideas in each one. For this section especially, have everyone go into separate rooms to create their ideas. Once everyone\u2019s done, come together and discuss.</p>"},{"location":"the-season/#categories","title":"Categories","text":"<p>You may want to add other categories depending on what the game calls for.</p> <ul> <li>Scoring mechanism</li> <li>Descoring mechanism</li> <li>Drivetrain type (H, X, U)</li> <li>Wheel types</li> </ul>"},{"location":"the-season/#ideas","title":"Ideas","text":"<p>I can\u2019t cover each idea in each category, since I don\u2019t know what game you\u2019ll use this for, but I can talk about the general way to formulate ideas. Make sure to draw and write out your examples.</p> <ol> <li>Think really hard about the category you\u2019re working on</li> <li>Think about what you did the previous year (if it applies)</li> <li>Do a small pro/con about it</li> <li>Repeat for designs that you\u2019ve seen other teams use</li> <li>Repeat for designs that you\u2019ve seen in previous games</li> <li>Repeat for designs you just made up</li> <li>Think about how each idea affects the current game</li> </ol> <p>I\u2019ll do one for drivetrains:</p> <ol> <li>We used an H-Drive last year</li> <li>Pro: really fast in a straight line, Con: didn\u2019t turn very well</li> <li>Other teams used X-Drives</li> <li>Pro: turned really well and was fast, Con: was easy to push</li> <li>Theoretical is the U-Drive (front-end H-Drive, back-end X-Drive)</li> <li>Pro: better turning, Con: different speed wheels may have a negative effect</li> <li>Maybe you think this game will be played without as much defense, so you can use an X-Drive since it\u2019s Con won\u2019t affect too much.</li> </ol> <p>Once your team has formulated all their ideas, regroup and share them. Talk about each pro and con and write them up into one sheet per idea.</p>"},{"location":"the-season/#scoring-solutions","title":"Scoring Solutions","text":"<p>Decide on one method to score solutions, some popular ones are below:</p> <ul> <li>Democracy - Each person votes for the best design</li> <li>Rank the Designs - Each person ranks all the designs and assigns points to them. When totaled, whichever has the most is chosen</li> <li>Lead - Either the leader or lead builder chooses what they think is best</li> <li>Scoring - The entire team assigns a point value to each design, the highest is chosen</li> </ul> <p>You\u2019ll want to decide on your top 1 or 2 ideas from each category. You may need to rebuild portions of your robot, so having a semi-developed idea to fall back on is useful. Remember to think about how each design influences the game. Use your pros/cons to guide you. Some designs may affect designs in a different category, so you\u2019ll want to think about that. Once you\u2019ve narrowed your selection, choose the ones you\u2019ll start building with. You may want to look to the lead builder for this. If you think the chosen design is a mistake, talk it out a bit more. You\u2019re early enough in the season that you can flesh out plans and not have it hurt.</p>"},{"location":"the-season/#meetings_1","title":"Meetings","text":"<p>Once you\u2019ve decided on your top design for each category, your next move is to start building, coding, and driving. Even though each section has its own specialties that will be broken down below, the following is true for all of them. You need to repeat the engineering design process (EDP). If you aren\u2019t familiar with the EDP, it says that you create something, test it, analyze the results, and improve it. So if you build a drivetrain using chain, you then code it, then drive it. Let\u2019s say that your sprockets are slipping, you deduce that the problem is your chain is too loose. You improve it by removing links. Since nothing can be perfect, at the end of a cycle, you will have to move on to another piece of your robot. It\u2019s as important to see everything as a whole as it is to see it separately.</p>"},{"location":"the-season/#start-of-the-meeting","title":"Start of the Meeting","text":"<p>The leader should have a plan for what they want completed during each meeting. Try not to be late, so you don\u2019t miss the plan. If you\u2019re the lead builder, coder, or driver you may also have specific plans of what you want to do. Once everyone understands what needs to be done, the respective people start on their tasks.</p>"},{"location":"the-season/#middle-of-the-meeting","title":"Middle of the Meeting","text":"<p>This is when you get to work on building, coding, and driving. At the beginning of the season, your meetings will most be building. The middle will be coding. The end will be driving. Obviously there will need to be small build or code fixes along the way, and the driver will need to test some mechanisms out, but that is the general flow.</p>"},{"location":"the-season/#building","title":"Building","text":"<p>With your designs decided on, you\u2019ll need to start somewhere. I recommend starting with CAD. You can CAD out specific subsystems and then build them up to create your entire robot. CAD is very nice since they act as exact blueprints. The lead builder would most likely do the CAD with other builders helping. You can also start with graph paper and drawing out 2D designs. Even though it isn\u2019t ideal, you can draw out drivetrains and other simple mechanisms. Build the drivetrain first and then build the rest of your robot piece-by-piece. After each part is built, get it coded and tested and then improve it. Large-scale rebuilds are another important part of building. You may see that you need to rebuild after going to a tournament and realizing that your robot doesn\u2019t hold up. Or you may realize that a design doesn\u2019t work for reason X while designing it. Don\u2019t be afraid to rebuild large parts of your robot, just make sure you have enough time to. You may have to start at square 1, but having a solid starting point is key.</p>"},{"location":"the-season/#coding","title":"Coding:","text":"<p>After a part is built by the build team, you want to code the controls immediately. Coding for driver control does not take very much time and can be done even if the rest of the robot has not yet been built. You should always try to code basic controls while the rest of the robot is being worked on by the build team. After you have coded your drive controls, you\u2019ll want to begin working on autonomous programs immediately. The process is simple: write out your functions, then run the autonomous functions, and make small changes until the autonomous function works consistently. Finally, once you are done with your autonomous, or have made significant progress, let the driver test the controls and practice. While testing your driver may come up with suggestions for better controls or ways to automate something. Your job will be to make that happen as quickly as possible to make the driver\u2019s job as simple as possible.</p>"},{"location":"the-season/#driving","title":"Driving:","text":"<p>Once the part is built and coded, it needs to be tested. (Jan: write something that talks about EDP in driving, end it with sending it to the builder to fix)</p>"},{"location":"the-season/#end-of-the-meeting","title":"End of the Meeting:","text":"<p>Find a good spot to stop working and then pack up. Make sure your workspace is clean since other people may have to use it. If this is the last meeting before a tournament, you will pack up differently. That\u2019ll be discussed in The Tournament. When you leave, you\u2019ll need to have a small reflection and plan for the next meeting. Think about what goals you completed and what goals you didn\u2019t. You might realize that something didn\u2019t work, so you\u2019ll need to create something else. The leader will dictate what needs to be done, but you have power over how it gets done.</p>"},{"location":"the-season/#conclusion-of-the-season","title":"Conclusion of The Season","text":"<p>Oddly enough, the season never really ends. But for all intensive purposes, the season takes a break when you go to tournaments. You want to remember that you\u2019re making a robot to compete. You need to be able to make deadlines that put your work on the spot. Many times you will not complete all your goals before the deadline. You only need to complete as many as it takes to get your robot working.</p>"},{"location":"the-tournament/","title":"The Tournament","text":"<p>So even though tournaments are the best part of robotics, they can be very stressful. First, let me reiterate why you are building and coding your robot: to go to the tournaments. While the builders and coders work for most of the regular season, the driver works the most during the tournament. Now hopefully, you have a robot that does what you want it to do. But many times, especially early on, things break and don\u2019t work. Oddly enough, things break more often later on because they\u2019ve seen more action. You\u2019ll always need to fix your robot at competitions.</p>"},{"location":"the-tournament/#pre-tournament","title":"Pre-Tournament","text":"<p>This will be an entire meeting in itself. It should be a driving-centered meeting, but depending on the state of your robot, other things may be more important than the ones listed below. Don\u2019t break your robot, or drastically change it.</p>"},{"location":"the-tournament/#driving-practice","title":"Driving Practice","text":"<p>Set the field up, or don\u2019t, put a new battery in, and drive. For this, your driver should get ample time to get a feel for the robot. I recommend starting the practice how you would start a match after auton or how you would if your auton fails. Also get ready to fix any minor bugs in the robot or in the code. Don\u2019t let your motors overheat as you\u2019ll ruin your robot.</p>"},{"location":"the-tournament/#scrimmages","title":"Scrimmages","text":"<p>You can also do driving practice against sister teams to give practice a more realistic sense. 1v1 or 2v2 work here, depending on how many teams are actually available. See if there are things your driver can improve on or if there are minor fixes to your robot. Suggest them after the match.</p>"},{"location":"the-tournament/#skills-practice","title":"Skills Practice","text":"<p>1 minute on the clock, set up the entire field, and prepare your robot. Skills runs are harder to do at meetings since other teams likely need to use the field at the exact moment you do. I recommend having multiple paths planned out, so that your driver can test out different paths and score higher.</p>"},{"location":"the-tournament/#auton-practice","title":"Auton Practice","text":"<p>When your driver needs a break, run the auton. You can do this before the driving practice so that the robot is already set up. Have one person reset the field, one person reset the robot and one person change the code. Do a few tests each time you change the code, to see if your robot is consistent.</p>"},{"location":"the-tournament/#ending-the-meeting","title":"Ending the Meeting","text":"<p>Once your robot is finished, your code is debugged, and your driver has enough practice, pack up your robot. Also pack up spare parts that you\u2019ll need and some that you won\u2019t. Don\u2019t forget tools like dremels or metal cutters. Extra batteries and maybe an extra cable are useful. Bring rubber bands and zipties too. Try to get a good sleep or follow the tradition of all-nighters. Make sure you and everyone else has a ride to the tournament.</p>"},{"location":"the-tournament/#pre-matches","title":"Pre-Matches","text":"<p>Once you arrive at the tournament, you\u2019ll need to prepare your robot, do some testing, and mentally prepare yourself. First of all, make sure your robot and team (especially your driver) is there. People may come in late, so be prepared to work with less teammates or to be thrown into the mix if you\u2019re late.</p>"},{"location":"the-tournament/#inspection-and-check-in","title":"Inspection and Check-In","text":"<p>Once your robot is there, bring it to the inspection table. Finish up your notebook and bring it to the check-in table, the judges will take it and return it at the end of the tournament.</p>"},{"location":"the-tournament/#practice","title":"Practice","text":"<p>Next, you\u2019ll need to warm your driver up. Practice your auton, practice general driving. Whatever you practice, you\u2019ll never have enough space on the practice field. Make sure to run your auton a few times so that you know it works. Here is also where you should make minor changes to your robot. The most important thing is that you don\u2019t break your robot during practice.</p>"},{"location":"the-tournament/#scheduling","title":"Scheduling","text":"<p>Once the schedule is released, you\u2019ll know when your matches are and who they\u2019re against. From this you can deduce such things as: probability of winning, when you should do skills, and when you should try to get judged. Knowing how good your team is and how good other teams are will let you know if you have an easy schedule or a hard one. You should also plan when you can do skills, a large stretch between matches is ideal. VEX also offers two apps: VEX via and VRC Hub.</p>"},{"location":"the-tournament/#other-tips","title":"Other Tips","text":"<p>You\u2019ve practiced and you know your schedule, what\u2019s next? Keep your pockets full: Keep screws, nuts, a screwdriver and a wrench, and small pieces of metal in your pockets. Don\u2019t forget rubber bands (I keep a bag on my belt), zip ties (in the bag), and a spare battery (back pocket). I would also suggest goggles for the drive team. Eat: Make sure you eat something every once in a while and drink some water.</p>"},{"location":"the-tournament/#qualification-matches","title":"Qualification Matches","text":"<p>Please take everything said as guidelines, and that you should cater to your driver.</p>"},{"location":"the-tournament/#drive-team","title":"Drive Team","text":"<p>Your driver will select up to 2 other members to be the drive team. Their job is to give useful information to the driver such as time remaining, where game objects are, and strategies. Depending on what your driver wants to hear some people may be better drive team members than others. Wear your goggles!</p>"},{"location":"the-tournament/#preparing-the-robot","title":"Preparing the Robot","text":"<p>Get to the prep table 1-2 matches before your own. Talk to your teammate about auton and which one to use. You may also want to talk about strategies. Make sure that your robot is actually ready. Replace old rubber bands, swap for fresh batteries, anything that can tire will need to be replaced at some point. When you get on the field, set up your robot and ensure that the field is set up correctly. The drive team should be with the driver, and everyone else should be in the stands. The match will start, 2 minutes will pass, and it\u2019ll be done.</p>"},{"location":"the-tournament/#mid-matches","title":"Mid-Matches","text":"<p>You should welcome match breaks as your only downtime during the stressful day. But, this is not the case as most times you will have to do robotics related work. Your breaks will range from 5 minutes to 30. On every break you\u2019ll need to fix minor changes on your robot or in the code and on every long break you should try to do judging or skills.</p>"},{"location":"the-tournament/#scouting","title":"Scouting","text":"<p>Scouting occurs throughout the entire tournament. Even at the beginning of the tournament, someone should be scouting. Many times sister teams compile 2-3 people to scout together. They should switch with others as scouting can become tiresome, especially since there can be many qualification matches. Scouts watch as many matches as they can to see which robots are good and which aren\u2019t. You will need the information your scouts found during the elimination matches. Scouts should look for auton accuracy, offense, defense, and general driving. Since each game is different, you may want to add different categories in your notes.</p>"},{"location":"the-tournament/#skills","title":"Skills","text":"<p>Keep an eye on the skills line as it can build up very quickly in large tournaments. When you have a large break between matches, about 10 minutes if the line is short 20 minutes if it isn\u2019t, you should do skills. Your driver will have 1 minute to score as many points as they can.</p>"},{"location":"the-tournament/#judging","title":"Judging","text":"<p>When the judges come to your table, you should try to have your interview unless you have a match immediately. If you have to delay it, try to give them a time when they can return. Make sure everyone is there, introduce yourselves and mention if people didn\u2019t make the tournament. Use this accompanying slideshow: Teresa\u2019s Judging Guide</p>"},{"location":"the-tournament/#about-the-robot-slides-3-5","title":"About the Robot (Slides 3-5)","text":"<p>First talk about your current design. We have the lead builder mostly talk about it, with people chiming in when necessary. Make sure to discuss defining parts of your robot and how those parts help you play the game. You may want to include relevant game stats that you can complete during a match. Also describe how your robot is different from other robots to give the judges\u2019 a perspective. You\u2019ll also want to talk about pros and cons of your robot. Mention as much as you need to but don\u2019t put your robot down too much. Have a secondary builder talk about your previous designs, mentioning the previously said things.</p>"},{"location":"the-tournament/#more-on-the-design-slides-6-9","title":"More on the Design (Slides 6-9)","text":"<p>If things haven\u2019t been mentioned about the build, mention them here. If people haven\u2019t talked a lot, let them talk. If the entire team understands the design, the judges will notice. Talk about general things like why the design is effective, what it lets you do, why it isn\u2019t the best, and any trade-offs you made. Try to wrap up what you have to say about the robot now, as you don\u2019t want to sidetrack when you\u2019re talking about coding.</p>"},{"location":"the-tournament/#about-the-code-slides-11-13","title":"About the Code (Slides 11-13)","text":"<p>Have the coder talk through this section, but have the driver on standby incase code needs to be demonstrated. Start with explaining auton and all the situations of each. It may be a good idea to mention future auton ideas to show that you\u2019re thinking ahead. Next talk about the controller functions with the driver adding notes. You can do some actual examples here to help explain. Make sure to talk about macros and unique code and how they help the driver. The largest part to mention for all of this is advantages and disadvantages with the code and the drive. You can spend as much time talking about code as you do talking about the design.</p>"},{"location":"the-tournament/#other-pointers-slides-14-19","title":"Other Pointers (Slides 14-19)","text":"<p>Mention driving strategies as a lot of people don\u2019t. Mention any small things about the robot, the code, the drive, or any behind-the-scenes strategies. Once you learn physics, you can talk about basic relations or even use actual measurements. Anything Teresa has mentioned that was the reason she won, you should include. Judges look for very specific things and those comments are coming directly from judges. This is the guide that judges use: Judge Guide This is rubric for the interviews: Interview Rubric This is rubric for the design award, which is based on your judging and notebook: Design Rubric Other Things To Do Sometimes you just need to take a break between matches. Other times you need to rebuild half your robot. First, make sure you eat and drink some water. Staying somewhat healthy is necessary. Next, refrain from too much practice as you don\u2019t want to wear out your driver or your robot. But if something needs to be tested or a bug needs to be fixed, test it. Third, you\u2019ll want to do some auton practicing and correction. If you think you\u2019re alright, take a break.</p>"},{"location":"the-tournament/#elimination-matches","title":"Elimination Matches","text":"<p>After your qualification matches, each team will be ranked by win points. Assuming you\u2019ve done well enough in the tournament you\u2019ll get to pick your partner. If you haven\u2019t, hope to get picked.</p>"},{"location":"the-tournament/#alliance-selection","title":"Alliance Selection","text":"<p>Once each team is ranked, they\u2019ll repeat this process for determining the alliances: The highest ranking team announces their partner team The team can either accept or decline If they accept, the 2 teams become an alliance and it repeats for the next team If they decline, the selected team can\u2019t be selected by anyone else, but can still choose a partner if they have the chance. The first team returns to step 1.</p> <p>Before alliance selection, you and your team should sit down and come up with a list of the teams that you want to pick and what happens if someone picks you. Trying to figure everything out can be hard, but if you think through methodically, you\u2019ll do fine.</p> <p>So, the highest teams basically get any team they choose and lower teams have to go with whoever picks them. If you are a lower team and get picked, you say yes. Higher teams have more strategy. You\u2019ll want to consider the following: Scouting notes - you didn\u2019t take these for nothing, good notes will result in good picks Auton scoring - the more consistent auton is always a good indicator of a good team Previous partners - playing with someone previously can determine if they\u2019re good or not If worse comes to worst, either pick the highest ranking team you can (they\u2019re there for a reason) or pick a sister team (you can at least have fun with friends).</p> <p>What happens if you\u2019re highly ranked and get picked? Again, you\u2019ll want to have decided beforehand whether to accept or decline. Consider: If you decline, will they take your pick? Can you still do well without that pick? If you accept, are they the best match for you? This is a hard situation to be in and discussing it with your team is the only correct answer.</p> <p>You should also talk to other teams about alliancing or not alliancing. Remember, if a team you don\u2019t want to partner with picks you, you can\u2019t get picked again. So, you can either risk it, or ask them not to pick you. Both are entirely fine. If you want to pick a team, you should approach them and ask them if they want to alliance. If they say no, you should respect that. If they say yes, you should try to pick them. When talking to another high ranking team, you\u2019ll want to talk through the possibility that either of you can get picked by another high-ranking team. Since each team has their own right at the win, each team has to respect another\u2019s right. This comes up when each team wants to get picked by the highest team, but can\u2019t and therefore has to create contingency plans that benefit themselves the most.</p> <p>As a wrap-up, because alliance selection is confusion:</p> <ul> <li>If you\u2019re high on the scoreboard:<ul> <li>Pick a team who is good and wants to be picked by you</li> <li>If you\u2019re picked, ask yourself if you want to play with that team or take a chance on another</li> </ul> </li> <li>If you\u2019re middle on the scoreboard:<ul> <li>Pick a team you can have fun with</li> <li>If you\u2019re picked, make sure it\u2019s a team you have a decent chance with</li> </ul> </li> <li>If you\u2019re low on the scoreboard:<ul> <li>If you\u2019re picked, say yes because you might not be able to pick</li> </ul> </li> </ul>"},{"location":"the-tournament/#elimination-matches-elims","title":"Elimination Matches (Elims)","text":"<p>Your matches here will be just like your qualification matches, except now you have a set partner. Just make sure that you get to your match on time and do your best.</p>"},{"location":"the-tournament/#time-out","title":"Time-Out","text":"<p>For all of the Elims, your alliance gets 1 time-out. Generally you save your time out to finish a repair or an auton before the semi-finals or finals. Each time-out is 3 minutes long. Use it properly.</p>"},{"location":"theory/","title":"Theory","text":"<p>I started this book, like I said previously, to give freshmen the resources to learn and for senior members to teach. But this book was also meant to compile the knowledge that we had and the ideas that we formed. One of the most prominent ideas that we formed was drawn from the fact that our club was at a low point. So, we developed a solution, not robotics driven as you\u2019ve seen previously, but driven solely off of our experiences and common sense. This is theory; the idea that you can solve a problem in the club by changing the club.</p> <p>The Area 53 Team Division Manifesto</p>"},{"location":"theory/#teams","title":"Teams","text":"<p>In the manifesto, we first define a good team. It\u2019s basically a group of friends that work well together and fit each position on a team well. They don\u2019t have to win, but they are the best team because they can enjoy their friendship when robotics sucks and enjoy both when it\u2019s great.</p> <p>We next define different types of teams. An optimal team is well rounded, contains skilled members, and should be able to compete highly. It is commonly an exceptional tiered, concentrated, or team of X team. A tiered team is a team that cycles through members consistently. They have consistent strength and are normally mid-tier because of this. A concentrated team is a team that is made up of one grade level. They are weak early on, but are very strong later. A team of X is a planned team with few members. The members are usually grouped to win. A team of X by force is when there are many members on a team, but only X of them do work. These are the worst teams as the non-working members drag down the team. We also define competitiveness here. You know a competitive member by how they carry themselves in practice and in competitions. Competitiveness plays a large part in what types of teams are formed.</p> <p>Once we defined everything, we proposed how many teams of each type Roosevelt should have. This is bound to change, but gives a good sense of a healthy club.</p>"},{"location":"theory/#new-members","title":"New Members","text":"<p>We start by defining types of people. You can\u2019t tell what types of people incoming members are, but when you do grouping them accordingly is a necessity. According to the previous section, competitive, mid-competitive, and non-competitive teams tank similarly to this ranking. Avoid having the last 2 groups of people in the club as much as possible as they can waste spots.</p> <p>When admitting new members onto teams the current way is random distribution. This allows new members to learn immediately and develop. This method has worked previously and will likely be used again unless specific teams need to be made. But, there are some other untested ways that can yield different results. Tryouts is a very simple task to do a quick check to judge their attitude. It is the most basic method and the most inconclusive. If you have some knowledge about them, teams can draft the new members. This is a more complex task, but can yield great results especially for tiered teams. Team mentors lets existing teams create new teams out of new members no matter the experience. This is a very complex task, but can yield very powerful concentrated teams.</p> <p>You\u2019ve probably noticed that the Team Division Manifesto didn\u2019t include how to recruit people. We\u2019ve noticed 3 different ways with 3 different outcomes. The first is word of mouth, which yielded few but dedicated members. This method will probably never be used primarily again. The second is morning announcements, which worked the best. We got a large crowd initially, but it then reduced to a group of dedicated members. Notably, parents were never involved if the person didn\u2019t join the club. The third is the open house, which worked horribly. We got too large of a crowd and catered to parents instead of kids. We were left with members that were here because of their parents.</p>"},{"location":"theory/#how-to-change-the-club","title":"How to Change the Club","text":"<p>I\u2019ve told you our thoughts on team distribution and freshman integration. But there are a lot of problems that we haven\u2019t faced that you might and if we\u2019ve faced the same problem, it\u2019ll probably be in different circumstances. This section was meant to give you a jumping off point so you can start changing the club in different ways. Sadly enough, it\u2019s hard to change the structure of the club once you\u2019re already nose-deep, but there are cases when you have to do something. Sit down with dedicated members and talk through it. We started this book and it\u2019s documents for you, you\u2019ll need to update it for the next freshmen.</p>"},{"location":"hardware/introduction/","title":"Hardware","text":"<p>Building might be one of the hardest techniques because there\u2019s always something new. When your robot breaks, it\u2019s because of the building. Your coder\u2019s limit, it\u2019s defined by the building. Your driver\u2019s capabilities, it\u2019s defined by the building. Your little sibling breaks your robot, you should\u2019ve built it better. This section is going to be broken down into 3 subsections each with their own topics. These topics may be new, they may have been repeated a thousand times (they should probably be repeated again). Either way, these topics should help you improve your robot. But implementing them is not enough. A good builder needs to know how to build well and take into account their coder\u2019s and driver\u2019s needs. I can\u2019t discuss that, but when you can take your coder\u2019s or your driver\u2019s idea and implement it semi-perfectly, you\u2019ve made it.</p>"},{"location":"hardware/moving/","title":"Moving","text":"<p>The next topic is moving relations. This isn\u2019t when you and your girlfriend move to different schools. You\u2019re in robotics, you wouldn\u2019t have a girlfriend. If something uses a motor, it\u2019s probably in this section.</p>"},{"location":"hardware/moving/#bearings-spacers-collars","title":"Bearings, Spacers, Collars","text":"<p>Knowing when to use bearing blocks, spacers, and collars is important. Any axle needs all 3 for clean building. There are tons of combinations, and only a few of them don\u2019t work. Bearings, Spacers, &amp; Collars Video (Stop at 7:08, that\u2019s when Rubber Bands starts)</p>"},{"location":"hardware/moving/#screws-vs-axles","title":"Screws vs Axles","text":"<p>In robotics, we can\u2019t use screws that are larger than 2.5 inches. Since your nylock is under 0.25 in, that gives you about 2.25 in of screw to work with. Also remember that axles go up to 12 in long. When deciding what to use for a joint you need to consider the size of the joint. If it\u2019s less than 2.5 in, use a screw joint; if it\u2019s more, use an axle. Pretty simple. The basic rule is to use screws until you can\u2019t. But why? In Stationary, I talked about slop. More moving parts are going to create a larger chance of slop, while less moving parts are going to reduce it. With screws, there are 2 \u201cmoving\u201d parts, the screw and the nylock. With axles, there are 3: the axle and 2 collars. Collars are also dangerous because we have really bad collars and they can come undone easily.</p>"},{"location":"hardware/moving/#rubber-bands","title":"Rubber Bands","text":"<p>An important non-VEX part that you can use are rubber bands. They have a lot of different uses but their main ones include:</p> <ul> <li>Tension for shooting mechanisms</li> <li>Tension for lifting mechanisms</li> <li>Releasing release mechanisms</li> <li>Rollers</li> </ul> <p>Shooting mechanisms like the puncher and catapult require rubber bands to pull them forwards. The slip gear pulls it back, tightening the rubber band and when no teeth are exposed, the rubber bands release, bringing the mechanism forwards. Lifting mechanisms are often heavy so we use rubber bands to hold some of the weight. Use them on any type of bar. Try to create a triangle that expands as the mechanism goes down, but shrinks as it goes up. Release mechanisms are pretty simple because you have something that holds the mechanism in while the rubber bands are bending. When that object leaves, the rubber bands act and pull the mechanism into place. Rollers are similar to intakes in function, but not in design. They\u2019re 2 sprockets spaced apart on the same axle. In the grooves of the sprocket you string rubber bands to the other side. You can still use chain on these. Rubber Bands Video (Stop at 10:18, that\u2019s when Gears, Sprockets, &amp; Ratios starts)</p> <p>Rubber bands are very useful and there are many types of rubber bands. We commonly use size 64. We also buy from the company Advantage as they have a lot of different types of rubber bands. Some are more stretchy and work better at longer distances, some are sturdier and work better at shorter distances. Buy the ones you want to try and test them. It\u2019s probably a good idea to have multiple styles on hand. Generic Staples rubber bands also do the job. Since you\u2019re using rubber bands frequently and they usually pull large forces, it\u2019s good to replace them often. You might need 2-4 sets of rubber bands for a tournament. Keep track of how many rubber bands you need and where you need them so you can be prepared. Also try to use old rubber bands that have lost their elasticity for simple mechanisms like anti-tips. Rubber bands may also tear or cut, so make sure you get rid of them. I like to tear them apart so we know we can\u2019t use it.</p>"},{"location":"hardware/moving/#gears-sprockets-and-ratios","title":"Gears, Sprockets, and Ratios","text":"<p>I\u2019m not going to talk about when to use gears and sprockets because they\u2019re very similar and pretty obvious when you need to move power around. Although a good rule of thumb is to use gears for short ranges and sprockets for large ranges. This section is about gear ratios and how to use them. I\u2019m only going to be using gears as my example, but know that sprockets work the same. Also, because I might have not said this, we have 3 speeds of motors: 100rpm, 200rpm, and 600rpm. The higher the rpm, the lower the torque. Torque is the inverse of speed. If you need to go fast, you want a high speed, while your side effect is a lower moving capability. If you need to move something heavy, you want a high torque, while your side effect is a lower speed.</p> <p>Gear A to Gear B results in B/A times torque and A/B times speed The ratio is then called A/B simplified. If Gear A is smaller, you\u2019ll get higher torque, lower speed. If Gear A is larger, you\u2019ll get lower torque, higher speed.</p> <p>If there are 3 or more gears, Gear A is powered by the motor and Gear B is the farthest most gear.</p> <p>I\u2019ll go through a written example too. If we have a motor driving a 12 tooth (A), which then turns a 36 tooth (B), we get 3x higher torque and 3x slower speed. So let\u2019s say our motor is driving at 600 rpms. Our 36 tooth is driving at 200 rpms and our 12 tooth is driving at 600 rpms. Lower rpms deliver higher torque, while higher rpms deliver higher speeds.</p> <p>That\u2019s simple gears. Let\u2019s say you have a motor powering Gear A. Gear A then powers Gear B. Gear B is on the same axle as Gear C. Gear C then powers Gear D. We\u2019ll use the same example. The motor is 600 rpms, Gear A and C are 12 tooths, Gear B and D are 36 tooths. Gear A experiences 600 rpms. Gear B experiences 200rpms. Gear C also experiences 200 rpms. Gear D then experiences 200/3 rpms. We get 9x higher torque and 9x slower speed from Gear D. By placing gears on the same axle to transfer power, we multiply each ending gear together. One way to think about it is the motor powers Gear A which transfers it to B. Then Gear B acts as the motor that powers Gear C which transfers it to D.</p>"},{"location":"hardware/moving/#custom-parts","title":"Custom Parts","text":"<p>Here we\u2019re talking about slip gears and ratchets. Slip gears allow for punchers and catapults to work, they don\u2019t have too many other uses. If your mechanism can translate into a puncher or a catapult then use a slip gear. If it doesn't, then see if you can use something else. Ratchets allow you to move a mechanism one way and one way only. If your mechanism needs to move one way, consider using these.</p>"},{"location":"hardware/stationary/","title":"Stationary","text":"<p>Our first topic is stationary relations. This includes a lot of metal to metal contact and objects that are stationary relative to the object they\u2019re attached to. Most of the framework for your robot is here, while the magic that makes it move is in the next section.</p>"},{"location":"hardware/stationary/#nylocks-vs-crowns-keps","title":"Nylocks vs Crowns (Keps)","text":"<p>Use Nylocks when:</p> <ul> <li>You\u2019re screwing in a load bearing joint (a screw in a nut)</li> <li>You\u2019re using a screw joint</li> <li>Any important connections and if you have them any time you can</li> <li>Use Crowns when:</li> <li>You\u2019re testing designs or you\u2019re going to take them apart</li> <li>You\u2019re in a rush</li> <li>You need to hold spacers in a certain point on a screw (use them like collars)</li> </ul>"},{"location":"hardware/stationary/#parts","title":"Parts:","text":"<ul> <li>Standoffs - Use them with collars to hold up structures.</li> <li>1x1 L-Channel - Use these as a thin way to hold up structures.</li> <li>C-Channel - Use these as a sturdy way to hold up structures.</li> </ul>"},{"location":"hardware/stationary/#shapes","title":"Shapes:","text":"<ul> <li>Triangles - Create pythagorean triples (3, 4, 5 or 5, 12, 13). Use standoffs or 1x1 L-Channel. Use 90\u00b0 parts like pillow bearings, collars, or L-Channel to connect standoffs to the post or horizontal structure.</li> <li>Rectangles - Subdivide larger squares into smaller ones. Use standoffs, L-Channel, or C-Channel. These include cross braces that span your drivetrain and hold your braces.</li> </ul>"},{"location":"hardware/stationary/#balance","title":"Balance","text":"<p>Balancing your robot is important to not over-stress your drive motors. If you have too much weight in the back, the motors powering your back wheels will stress in trying to carry the weight. Some things you need to consider: Where the weight is in your robot w/o game parts Where the weight is in your robot w/ game parts If your center of gravity is high or low How force affects your robot Getting pushed from the front, side, or back Mechanisms that produce substantial force usually through rubber bands</p>"},{"location":"hardware/stationary/#how-to-fix-it","title":"How to fix it:","text":"<ul> <li>Careful Planning - When designing your robot, try to ensure your robot has a low center of gravity. This can be done by keeping as much of the weight low to the ground as possible. In particular, you want to keep as many of your motors low to the ground as possible, along with your robot\u2019s brain and battery. If your robot has steel pieces, they should also be low to the ground.</li> <li>Counterweights - These are mostly steel plates or C-Channels. If you have too much weight in the back, add plates in the front, or add a steel C-Channel as a brace in the front. If your robot is top heavy, you could replace some of your drivetrain C-Channel for steel. Put your counterweights where the actual weight isn\u2019t.</li> <li>Anti-Tips - These are used commonly with DR4Bs (double-reverse-4-bars) or long extensions of your robot. These are basically another set of wheels that extend from either the front or back of the robot. Usually they are a smaller set of wheels (3.25 in or 2.75in), rubber band-wrapped gears, or even pulley wheels (they\u2019re hard to find). Sometimes they\u2019ll extend using linear slides, others will flip out from the sides or back.</li> </ul>"},{"location":"hardware/stationary/#custom-parts","title":"Custom Parts","text":"<p>You are allowed to create certain parts in robotics. All of these have been mentioned in parts. Here we\u2019ll elaborate more on lexan and custom metal. Lexan is a bendable plastic that you can use. It can create better curves than metal (in this competition) because you don\u2019t have to bend it by hand. It can also create better gussets. You aren\u2019t allowed to use sheet metal in robotics, but there are a few ways around it. You can cut C-Channel or plates into different shapes to fit your needs. You can bend it to create curves, they aren\u2019t as good as lexan though. Understanding how to manipulate your lexan and metal will help you create better parts that fit your robot how you need them.</p>"},{"location":"hardware/basics/parts/","title":"Parts","text":"<p>There are a lot of parts. Some are obscure, some are necessary. Everyone should know how to be able to use simple parts well to fit their needs. If you need to use a part once, you should try to learn it fully. These files are very large and take about an hour in total to watch, but they should have all the knowledge you need to know about parts.</p>"},{"location":"hardware/basics/parts/#structure","title":"Structure","text":"<p>Note</p> <p>I forgot about a \u201crail\u201d, it\u2019s basically a worse C-Channel. I would only use them for bracing</p>"},{"location":"hardware/basics/parts/#motion","title":"Motion","text":""},{"location":"hardware/basics/parts/#hardware","title":"Hardware","text":""},{"location":"hardware/basics/parts/#electronics","title":"Electronics","text":"<p>Here is a link to learn more about sensors: VEX Sensors</p>"},{"location":"hardware/basics/parts/#custom-and-nonvex-parts","title":"Custom and NonVEX Parts","text":""},{"location":"hardware/basics/parts/#slip-gears","title":"Slip Gears","text":"<ul> <li>This is made from any plastic Vex gear.</li> <li>Used for lots of shooting mechanisms.</li> <li>When the gear is spun, it\u2019ll drive another gear when the teeth connect, but when the flat side of the slip gear contacts the gear, the driven gear won\u2019t move (or move into position of least tension).</li> </ul>"},{"location":"hardware/basics/parts/#ratchets","title":"Ratchets","text":"<ul> <li>Building</li> <li> <p>Examples</p> <p>I couldn\u2019t find a good picture of a ratchet, so here are 2 videos showing them. Ratchets are useful because they will only turn in one direction. Normally you have a 60 tooth gear with a screw insert, and a 12 tooth gear or 6 tooth sprocket (both with axle inserts) on an axle. You also have a rubber banded screw directly attached to the 60 tooth, which contacts the 12 or 6 tooth at an angle. When the 12 or 6 tooth turns, it will either brush over the head of the screw and not turn the 60 tooth, or push the screw and turn the 60 tooth.</p> </li> </ul>"},{"location":"hardware/basics/parts/#lexan","title":"Lexan","text":"<ul> <li>Clear plastic used for custom shapes.</li> <li>Many teams use this to create gussets for different angles or because the Vex ones suck.</li> <li>Lexan can also be bent.</li> <li>Must be cut from a 12\u201d x 24\u201d x 0.07\u201d sheet.</li> </ul>"},{"location":"hardware/basics/parts/#rubber-bands","title":"Rubber bands","text":"<ul> <li>Used to hold systems in place, propel systems, open systems, or give support to motors.</li> <li>Common uses:<ul> <li>Holding in anti-tips (wheels that prevent tipping)</li> <li>Shooting mechanisms</li> <li>Expanding trays</li> <li>Holding up lifts</li> <li>Advantage brand rubber bands are the best.</li> </ul> </li> </ul>"},{"location":"hardware/basics/parts/#zip-ties","title":"Zip Ties","text":"<ul> <li>Used to hold wires or other small systems in place.</li> <li>Should not be used structurally, be can in a pinch.</li> <li>Mainly used for wire management.</li> <li>My team once used them to hold our anti-tips in, not a good idea.</li> </ul>"},{"location":"hardware/basics/parts/#string","title":"String","text":"<ul> <li>Unlimited amount of \u215b\u201d braided, nylon rope.</li> <li>Used to hold systems in place against tension.</li> </ul>"},{"location":"hardware/basics/parts/#tape","title":"Tape","text":"<ul> <li>Used for wire management, or as a color for the Light Sensor</li> <li>Cannot be used for structural purposes.</li> </ul>"},{"location":"hardware/basics/tools/","title":"Tools","text":"<p>Here is a list of all the tools we have in robotics. They will be a picture, common names, and uses.</p>"},{"location":"hardware/basics/tools/#screwdrivers-and-wrenches","title":"Screwdrivers and wrenches","text":""},{"location":"hardware/basics/tools/#allen-wrench","title":"Allen Wrench","text":"<ul> <li>Also called an \u201cL\u201d or \u201cL wrench\u201d.</li> <li>Fits 8-32 hex screws, the common screw we use.</li> <li>This is the hardest hex driver to use, although it works best in small places and when supplies are short.</li> </ul>"},{"location":"hardware/basics/tools/#motor-allen","title":"Motor Allen","text":"<p>Same as the allen wrench, but fits 6-32 hex screws.</p> <p>6-32 hex screws are mainly used in collars.</p>"},{"location":"hardware/basics/tools/#t-hex-driver","title":"T Hex Driver","text":"<p>Also called a \u201cT\u201d or \u201cT wrench\u201d.</p> <p>Fits 8-32 hex screws, the common screw we use.</p> <p>This is another hard hex driver to use because of the long length of the driver as it can twist. But, works well for additional reach or torque.</p>"},{"location":"hardware/basics/tools/#german","title":"German","text":"<p>Fits 8-32 hex screws, the common screw we use. This is the best hex driver to use if you have it. It\u2019s very strong and it\u2019s amazing for anything in general.</p>"},{"location":"hardware/basics/tools/#wrench","title":"Wrench","text":"<p>The large head is used to hold nuts to tighten screws, the small head is used to tighten standoffs.</p> <p>Used with any hex driver or another wrench.</p>"},{"location":"hardware/basics/tools/#ratchet","title":"Ratchet","text":"<p>Used to tighten screws, but can only turn one direction.</p> <p>Useful in tight spaces where you can\u2019t turn 360 degrees.</p>"},{"location":"hardware/basics/tools/#saws-and-files","title":"Saws and Files","text":"<p>Wear eye protection when using any type of saw, especially a fast moving saw. Also please learn to use these from someone with experience before trying. I won\u2019t give any warnings here, so follow your instructor\u2019s instructions or the product\u2019s warnings.</p>"},{"location":"hardware/basics/tools/#dremel","title":"Dremel","text":"<p>Used to cut metal and various plastic parts.</p> <p>It\u2019s better to use a dremel to cut through steel and a hacksaw to cut through aluminum.</p>"},{"location":"hardware/basics/tools/#hacksaw","title":"Hacksaw","text":"<p>Used to cut metal and various plastic parts.</p> <p>It\u2019s better to use a hacksaw to cut through aluminum and a dremel to cut through steel.</p>"},{"location":"hardware/basics/tools/#snips","title":"Snips","text":"<p>Large scissors used to cut aluminum quickly.</p> <p>Often leaves the surface with rough edges.</p>"},{"location":"hardware/basics/tools/#file","title":"File","text":"<p>Used to remove sharp edges from metal.</p> <p>You can also use files to strip teeth off of a gear, although I would not recommend it (I\u2019ve done it before).</p>"},{"location":"hardware/basics/tools/#grinder","title":"Grinder","text":"<p>Also called a \u201cbench grinder\u201d</p> <p>Used to remove sharp edges from metal.</p>"},{"location":"hardware/cad/fusion360/","title":"Fusion 360","text":""},{"location":"hardware/cad/fusion360/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Download Fusion 360 from Autodesk.</p> <ul> <li>Fusion 360 Download</li> <li>Press \u201cGet Fusion 360 For Free\u201d</li> <li>Press \u201cGet Started\u201d</li> <li>Fill out the form</li> <li>Sign up with a personal email.</li> <li>You might need to give them proof of a school ID.</li> <li>If you don\u2019t have a school ID to take a photo of, take a screenshot of SchoolMax. Make sure the name of the school, your name, and the school year are visible in the image.</li> </ul> </li> <li> <p>Ask someone to add you to the Fusion team.</p> </li> <li> <p>Once you\u2019re in the team, you\u2019ll see in the upper-left hand corner the Area 53 team.</p> <ul> <li>Click on this to enter the team.</li> </ul> </li> <li> <p>You\u2019ll see some number of folders, this\u2019ll probably increase.</p> <ul> <li>Any folder of a team name is off limits, you can open the documents but you can\u2019t edit them.</li> <li>The VRC parts folder is for everyone\u2019s use and for everyone\u2019s builds. DO NOT edit these parts in the VRC parts folder. If you edit these parts, they will change in every build. If you need to edit them, make a copy of it first then edit it.</li> <li>There might be a new members folder. Please create a new folder under this to store your builds.</li> </ul> </li> <li> <p>Look at your toolbar on the top of your screen. If you see something called \u201cVEX CAD LIBRARY\u201d you\u2019re fine, if not download the add-in from below. You don\u2019t have to download anything else.</p> <ul> <li>https://www.vexforum.com/t/vex-cad-fusion-360-parts-library-release-log/83263</li> </ul> </li> </ol>"},{"location":"hardware/cad/fusion360/#further-reading","title":"Further Reading","text":"<ul> <li>VEX Fusion 360 Tutorial<ul> <li>Disregard the split body tool for cutting parts, there is a better method (step 5).</li> </ul> </li> </ul>"},{"location":"hardware/cad/introduction/","title":"CAD","text":"<p>Computer Aided Design (CAD) is a very powerful tool in planning out your robot.</p>"},{"location":"hardware/cad/introduction/#general-resources","title":"General Resources","text":"<ul> <li>Vex CAD Discord</li> </ul>"},{"location":"hardware/cad/inventor/","title":"Inventor","text":""},{"location":"hardware/cad/inventor/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Download Inventor from Autodesk.</p> <ul> <li>Inventor Download</li> <li>Press \u201cGet Inventor For Free\u201d</li> <li>Press \u201cGet Started\u201d</li> <li>Fill out the form</li> <li>Sign up with a personal email.</li> <li>You might need to give them proof of a school ID.</li> <li>If you don\u2019t have a school ID to take a photo of, take a screenshot of SchoolMax. Make sure the name of the school, your name, and the school year are visible in the image.</li> </ul> </li> <li> <p>Install the Inventor Library</p> <ul> <li>Inventor Library Download</li> </ul> </li> </ol>"},{"location":"hardware/cad/inventor/#further-reading","title":"Further Reading","text":"<ul> <li>BLRS Wiki: Inventor Chassis</li> </ul>"},{"location":"hardware/cad/onshape/","title":"Onshape","text":""},{"location":"hardware/cad/onshape/#getting-started","title":"Getting Started","text":"<p>Use the following instructions to set up an Onshape account, and use the VEX Parts Library.</p> <ol> <li> <p>Go to https://www.onshape.com/en/education/sign-up and select \"Create an Account\" on the website.</p> </li> <li> <p>Enter School information and other details, confirm your email, and create the account.</p> </li> <li> <p>Once your account is created and you are in the Onshape home page, click \"Public\" in the left menu.</p> </li> <li> <p>Click the search bar at the top, and in the \"Description\" box, type \"Official VEX V5 Library,\" and search.</p> </li> <li> <p>A variety of different sub-part libraries should appear. Select all of them, and right click. A small menu should appear.</p> </li> <li> <p>Select \"Labels\" and then click \"Create new label.\" Name it whatever you would like and create it. You should now have access to these libraries in any document. To use them, when in an assembly select \"insert\" from the top bar and then select \"Other documents.\" You should see your tag in the menu, which you can then click on to view all the vex parts, and insert them in your project.</p> </li> </ol>"},{"location":"hardware/cad/onshape/#further-reading","title":"Further Reading","text":"<ul> <li>V5 Parts Library Instructions</li> <li>Design Your VEX Robot in the Cloud With Onshape</li> </ul>"},{"location":"hardware/cad/solidworks/","title":"Solidworks","text":""},{"location":"hardware/cad/solidworks/#getting-started","title":"Getting Started","text":"<p>Before installing the new version of SOLIDWORKS, please uninstall all previous SOLIDWORKS versions and review the System Requirements.</p> <p>Please follow the instructions below to download the product:</p> <ol> <li> <p>Go to: www.solidworks.com/SEK and complete the form (first name, last name email address, select \u201cstudent team\u201d on dropdown)</p> </li> <li> <p>Under product information:</p> <ul> <li>Ask someone in the club for a serial number</li> <li>Select Yes ( I already have a serial number)</li> <li>Choose 2022-2023 version</li> <li>Input your serial number</li> </ul> </li> </ol> <p>If you do not activate the license after installing, you will only receive a 30-day license. Please give this serial number out to team members only. This serial number will expire July 31, 2024.</p> <p>Installation and activation instructions are here: www.solidworks.com/installation_instructions</p> <p>If for any reason you have a problem with the software installation, please go here www.solidworks.com/studentsupport.</p>"},{"location":"hardware/cad/solidworks/#further-reading","title":"Further Reading","text":"<ul> <li>Solidworks Course</li> <li>Solidworks Part Library</li> </ul>"},{"location":"hardware/subsystems/climbing/","title":"Climbing","text":""},{"location":"hardware/subsystems/drivetrain/","title":"Drivetrain","text":"<p>There are many things to consider when designing a drivetrain. Your drivetrain is important, so build it well. It might take you some time to do it, but it carries your robot, so it better be good.</p>"},{"location":"hardware/subsystems/drivetrain/#define-constraints","title":"Define Constraints","text":"<p>The first thing you should do when designing a drivetrain is decide what you are actually trying to accomplish.</p> <ul> <li>How fast do you want to go?</li> <li>Do you want to be able to resist pushing?</li> <li>Do you need to lift heavy objects?</li> <li>Do you need to cross any barriers?</li> <li>Do you need to fit through tight spaces?</li> <li>Do you need to have subsystems that extend outside of your drivetrain?</li> <li>Do you want to be able to strafe?</li> </ul> <p>Once you decide what you need your drivetrain needs to do, you can decide on what features it should have.</p>"},{"location":"hardware/subsystems/drivetrain/#features","title":"Features","text":""},{"location":"hardware/subsystems/drivetrain/#types-of-drivetrain","title":"Types Of Drivetrain","text":"<p>The most important feature is the type of drivetrain. This will dictate the rest of your decisions afterwards. There are many different styles of drivetrain, and they all come with their own advantages and disadvantages.</p>"},{"location":"hardware/subsystems/drivetrain/#tank-drive","title":"Tank Drive","text":"<p>This is the traditional style of drivetrain. It consists of at least 4 wheels, of a combination of omni and traction, in parallel.</p> <p></p> Pros Cons Easy to build Cannot strafe Hard to push around"},{"location":"hardware/subsystems/drivetrain/#h-drive","title":"H Drive","text":"<p>An H drive is similar to a tank drive, but has an additional driven wheel perpendicular to the rest of the drive that allows the drivetrain to strafe from side to side.</p> <p></p> Pros Cons Can Strafe Needs an additional motor"},{"location":"hardware/subsystems/drivetrain/#x-drive","title":"X Drive","text":"<p>An X drive has 4 omni wheels at 45 degree angles, forming an x shape. This allows the drivetrain to move in any direction at any time. It's also faster than a traditional tank drive. A more detailed explanation as to why can be found here. Note that this increase in speed comes with a proportional decrease in torque. It's wheels must be able to move individually, making it very hard to create gearing besides direct drive for it.</p> <p></p> Pros Cons Can Strafe Restricts you to 4 motors Faster than tank drive Less torque than tank drive"},{"location":"hardware/subsystems/drivetrain/#mecanum-drive","title":"Mecanum Drive","text":"<p>Mecanum drives use a similar wheel configuration to tank drives, but they use mecanum wheels instead of omni wheels. This allows them to strafe. Note that similarly to the X drive, the wheels must all be able to turn individually.</p> <p> }</p> Pros Cons Can Strafe Doesn't turn easily Restricts you to 4 motors Can't strafe as quickly as an X drive"},{"location":"hardware/subsystems/drivetrain/#size","title":"Size","text":"<p>For Omni or Traction wheels you generally want 6 holes wide. This allows you to fit an Omni wheel and a sprocket inside, even though it\u2019s tight. You do not need to have room for the wheel to turn like a car\u2019s wheels. Mecanum wheels may need more space because they\u2019re larger.</p> <p>The length of your drivetrain depends on what you want to do. A shorter drivetrain lets you have more open space in the front or back, but you might lose stability with farther back wheels. A longer drivetrain is going to let you be more stable, but you lose space. Many times when designing a drivetrain you should create it in 35 long or 30 long.</p>"},{"location":"hardware/subsystems/drivetrain/#wheel-size-and-gear-ratios","title":"Wheel Size and Gear Ratios","text":"<p>Overall, the main thing to take into consideration are the gear ratios of your drivetrain. There are some drivetrains that use chain to connect motors to wheels, but most modern VEX drivetrains use gears. VEX lets you choose from three motors, 100 RPM, 200 RPM, and 600 RPM. Keep in mind, the higher the RPM, the lower the torque.</p> <p>You can find a chart of different combinations and speeds here.</p> <p>The RPM that you choose is highly dependent on the amount of motors that you have. Typically 4 motor drivetrains use 200 to 300 RPM, while a 6 motor drive might use 200 to 360 RPM. Keep in mind that this is also highly dependent on the wheel size you use. There have been drivetrains using 450 RPM, but 2.75\" wheels.</p> <p>It all comes down to how fast you can go, while still having the ability to move without overheating your motors too quickly.</p>"},{"location":"hardware/subsystems/drivetrain/#structure","title":"Structure","text":"<p>The structure of your drivetrain is an easy part to neglect. You have to provide a solid base for the rest of your subsystems, and if you mess this up, the rest of your build will become a living hell. You need to ensure that your drivetrain maintains right angles and that it also doesn't flex.</p> <p>This comes in two parts:</p> <ul> <li>bracing the drive halves</li> <li>cross bracing the whole drivetrain</li> </ul> <p>When bracing your drive halves, make sure to brace on both the bottom and top of your C-Channel. This can take the form of more C-Channel, or standoffs, or anything else that can enforce the distance between the C-channel.</p> <p> </p> Credit to 99999V for this image <p>Cross bracing your entire drivetrain is also very important. Typically you want at least two C-channels that go across your entire drivetrain. This ensures that your drivetrain remains square. You can further guarantee this by exchanging these C-channels out for 3-channel, or even 5-channel, but this isn't required.</p> <p> </p> Credit to 99999V for this image <p>Remember, just because the metal looked straight in planning, doesn't mean it will actually turn out that way. Bracing is the only way you can guarantee that it stays in the shape you want it to.</p>"},{"location":"hardware/subsystems/drivetrain/#defensive-features","title":"Defensive Features","text":"<p>VEX Robotics is played in a competitive game. This means that there will inevitably be opposing robots trying to prevent your robot from scoring. One way teams will do this is by pushing your robot out of the way, typically from the side. This can be prevented by using a center traction wheel and/or adding skirts/wedges.</p>"},{"location":"hardware/subsystems/drivetrain/#center-traction-wheel","title":"Center Traction Wheel","text":"<p>A traction wheel in the center of your drivetrain is a very good way of preventing being pushed from the side. However, it is key that the traction wheel is located near the center of rotation for the robot, because it will have the least effect on the turning of the robot. Traction wheels have a lot of grip, but when a robot is turning, this grip works against it, because the wheel must drive in an arc, which means the wheel must skid somewhat. This is why we always recommend using omni wheels, because the small rollers help decrease the friction involved in turning. With the traction wheel in the center of the robot, however, the arc when turning is the smallest, which means the effect of friction is the lowest. Below is a CAD render of 53A\u2019s Worlds drivetrain for Tipping Point, which uses a center traction wheel, along with skirts.</p> <p></p>"},{"location":"hardware/subsystems/drivetrain/#skirts","title":"Skirts","text":"<p>Skirts are pieces of lexan mounted on the side of a drivetrain at an angle to prevent pushing. This works by creating a ramp for opposing robots to drive up if they try to push, thus reducing their pushing power in the horizontal direction. These are usually mounted on hinges and backed by a piece of c-channel for rigidity, although alternative methods can be used if hinges stick out past the c-channel too much. Below is a CAD screenshot of 53E\u2019s early season Tipping Point design, with a low profile custom hinge mechanism using standoffs and collars.connected to an 1-by angle.</p> <p></p>"},{"location":"hardware/subsystems/drivetrain/#wedges","title":"Wedges","text":"<p>Wedges are similar to skirts in that they are a slanted piece designed to cause other robots to ride up them, but wedges are mounted on the back of the drivetrain and typically used in a defensive manner to disrupt opposing robots. Below is a picture of 1721G\u2019s Change Up robot, which was a defense bot that utilized aggressive driving and wedges very well.</p> <p></p>"},{"location":"hardware/subsystems/drivetrain/#further-reading","title":"Further Reading","text":"<ul> <li>BLRS Wiki: VEX Drivetrains</li> <li>Designing a Quality Drive</li> <li>Designing Another Quality Drive</li> </ul>"},{"location":"hardware/subsystems/intakes/","title":"Intakes","text":"<p>Intakes are very efficient mechanisms that are widely used. There are many takes on them, but the most basic should work just as fine. Building intakes are very easy, although knowing which type to build can be difficult.</p> <p>Use flat intakes when:</p> <ul> <li>The object you need to pick up is flat</li> <li>You need 1 orientation for your object</li> </ul> <p></p> <p>Use single-sprocket intakes when:</p> <ul> <li>You need to get around a post and have intakes in front and behind the post</li> <li>You need to conform to a lot of different shapes</li> </ul> <p></p> <p>Use only tread when:</p> <ul> <li> <p>You need support, but nothing else</p> <p>Use chain-backed tread when:</p> </li> <li> <p>You need a lot of support</p> </li> <li> <p>This is when you have 3 sprockets stacked on top of each other with the top and bottom sprockets using chain and the middle sprocket using tread. The chain should be inside the tread and will provide support to the top and bottom of the tread.</p> <p>Use rubber band-wrapped gears or rubber band-wrapped, chain-wrapped sprockets or traction wheels when: You want a thin but solid intake Use omni-wheels when: You want your intake to be able to move up and down This will also increase the variability in your intakes</p> </li> </ul> <p>Another important thing to know about intakes is your release point. Compression also becomes a factor here. Compression describes the friction between 2 objects, 1 that you\u2019re trying to move. Too great and it\u2019ll stay still, too little and there\u2019ll be no force. For intakes this is especially important as they are constantly being used and efficiency is key. If your intakes need to extend in a direction make sure to consider this:</p>"},{"location":"hardware/subsystems/intakes/#flip-down-intakes","title":"Flip-down intakes","text":"<ul> <li>Swing down, allowing for vertical storage</li> <li> <p>If they are over-compressed, the screw joint will fail     Unstable closer to the end of the intakes     Flip-out intakes:</p> </li> <li> <p>Swing parallel to the ground, allowing for side storage</p> </li> <li>Allows for variable compression to a degree</li> <li>As long as they are kept parallel, they\u2019ll be fine</li> </ul>"},{"location":"hardware/subsystems/intakes/#punch-out-intakes","title":"Punch-out intakes","text":"<ul> <li>Uses linear slides to guide the intakes</li> <li>Exact compression</li> <li>Needs space for slides</li> </ul>"},{"location":"hardware/subsystems/introduction/","title":"Subsystems","text":"<p>Choosing the right options for your drivetrain and other systems is one of the hardest and most important parts of building.</p>"},{"location":"hardware/subsystems/lifts/","title":"Lifts","text":"<p>Lifts are necessary when you have to extend upwards. They need to be stable and sturdy because the load they carry is often heavy. The cascade lift is a weird lift and it\u2019s not used a lot, but I\u2019ve included a video that explains it. Things you should make sure to have on your lifts:</p> <ul> <li>Cross bracings (ones that are perpendicular to your lifting bars)</li> <li>X bracings (ones that cross your lifting bars)</li> <li>Triangle bracings supporting your posts</li> <li>Anti tips (we\u2019ll cover this more later, but helps with balance)</li> <li>Counter weights (use if needed)</li> <li>Screw joints</li> <li>Lifts are hard to make, but are very rewarding. Making lifts well is necessary, a good amount of games make your robot extend.</li> </ul>"},{"location":"hardware/subsystems/shooting/","title":"Shooting","text":"<p>Shooting mechanisms are interesting because you have to increase the velocity of a normally stationary object. You sometimes have to generate enough energy to push an object, meaning that you have to get your force and accuracy down.</p>"},{"location":"hardware/subsystems/shooting/#catapult","title":"Catapult","text":"<p>Catapults generate a lot of force because of the rubber bands, so make sure they\u2019re properly structured not to break. They are also difficult because the launch point (when the object leaves the catapult), determines where the object goes. You also need to perfect your slip gear, how many teeth you need to remove, because that determines how much power your catapult has. These take a lot of testing to perfect, but can carry a lot of objects.</p>"},{"location":"hardware/subsystems/shooting/#puncher","title":"Puncher","text":"<p>Punchers use a linear arm to strike an object. They generate a lot of force, and are more repeatable than catapults. They also take up little space. The difficulty in punchers lay in how you angle them. You can have one angle and move your robot, or you can have an angler that moves your puncher. A high-level puncher is very hard to make, but very beautiful when it works.</p>"},{"location":"hardware/subsystems/shooting/#flywheel","title":"Flywheel","text":"<p>Wheel spin fast. That\u2019s it.</p> <p>You need to make sure that your wheel can spin fast enough and that the ball can fly well. The hood angle is important because it determines where the ball goes. The compression on a flywheel is very important. Compression is the distance between two objects that help intake or shoot an object. If there is too much compression then the object will not travel very far because of the large amounts of friction. If there is too little there will not be enough force to shoot the object. This makes flywheels difficult to build well. Flywheels can shoot very far and are the most repeatable because they are almost always active.</p>"},{"location":"hardware/techniques/boxing/","title":"Boxing","text":"<p>Boxing is a technique that majorly increases the stiffness of structure. This involves putting spacers or standoffs inside of a C-Channel to stop it from being to bend:</p> <p> </p> Credit to 99999V for this image <p>You can also combine two C-Channels together:</p> <p> </p> Credit to BLRS Wiki for this image"},{"location":"hardware/techniques/bracing/","title":"Bracing","text":""},{"location":"hardware/techniques/bracing/#bracing","title":"Bracing","text":"<p>There are 2 main shapes that you want to create to support your robot: Triangles and Rectangles. You should use bracing to support posts (vertical metal) or any horizontal metal. This will help keep your robot sturdy, and stop parts from moving that shouldn\u2019t be moving. Bracing your robot will keep parts where you want them.</p>"},{"location":"hardware/techniques/canteleveration/","title":"Canteleveration","text":"<p>Canteleveration is a big word so let\u2019s break it down. Cante: Spanish word for sing in first person singular. Lever: lots of force on one side. Basically, it\u2019s a structure that\u2019s only supported on 1 side. This can range anywhere from axles to C-Channel. Axles are obvious because you need to support each side with metal and bearings. There is one exception here: You can have one side of the axle exposed if there are 2 pieces of metal supporting the other end. C-Channel is a bit more obscure because if you joint it properly, it might not need the extra support. But, if it\u2019s able to be supported, it\u2019s probably worth doing.</p> <p>I accidentally canteleverated a bearing block. I was only able to screw in 1 side of the bearing because of lack of spacing for the other screw head. The axle was in the middle. There was so much weight on the axle that it pushed the bearing down. Canteleveration extends to jointing small things too.</p>"},{"location":"hardware/techniques/joints/","title":"Joints","text":"<p>A joint is a connection between two parts that allows for rotation.</p> <p>Here is a video overview of the different joint types:</p>"},{"location":"hardware/techniques/joints/#further-reading","title":"Further Reading","text":"<ul> <li>BLRS Wiki: Vex Joints</li> </ul>"},{"location":"hardware/theory/gear-ratios/","title":"Gear Ratios","text":"<p>Gear ratios are a key part of being able to influence speed an torque. A gear ratio consists of at least two gears or sprockets of different sizes. Every system has a driven and driving gear. The ratio is only determined by these two gears, all of the other gears can be ignored.</p> <p></p> <p>Here is the formula for a gear ratio:</p> \\[ GearRatio=\\frac{Driven}{Driving}=Driven:Driving \\] <p>A gear ratio with a smaller gear to a larger gear will result in an increase in torque, while a larger gear to a smaller gear will result in more speed.</p> <p>Here's an example:</p> <p>If we have a motor that spins at 200 RPM, and then connect that motor to a 60 tooth gear which drives a 36 tooth gear, we now have a gear ratio of \\(60:35\\), or \\(5:3\\). Our final gear ratio is now \\(200*(5/3)\\), or \\(333.\\overline{3}\\) RPM.</p>"},{"location":"hardware/theory/stress/","title":"Stress","text":""},{"location":"hardware/theory/stress/#further-reading","title":"Further Reading","text":"<p>Just read this.</p>"},{"location":"hardware/theory/torque-speed/","title":"Torque and Speed","text":""},{"location":"hardware/theory/torque-speed/#torque","title":"Torque","text":"<p>Torque is rotational force. Torque can be calculated with the following equation:</p> <p>Assuming that:</p> <ul> <li>\\(\\tau\\) is torque, measured in newton meters (N-m)</li> <li>\\(r\\) is the distance to the center of rotation, measured in meters (m)</li> <li>\\(F\\) is the force applied to the object, measured in newtons (N)</li> </ul> \\[ \\tau=r*F \\] <p>This means that the farther out force is applied, the greater torque is. This means it is easier to move something the farther away from the center of rotation. This is why doorknobs are as far as possible away from the hinges as possible. Torque is relevant whenever you have a rotation system, usually when you have a motor involved. Torque is typically important whenever you need to lift heavy objects, or quickly accelerate.</p>"},{"location":"hardware/theory/torque-speed/#speed-rpm","title":"Speed (RPM)","text":"<p>Speed is, obviously, how fast something moves. We'll be focusing on rotational speed, measured in rotations per minute (RPM). This can be calculated quite simply as the amount of full rotations made around the center of rotations in a minute.</p>"},{"location":"hardware/theory/torque-speed/#relationship","title":"Relationship","text":"<p>Torque and speed are strongly correlated. You can use these equations to calculate the relationship between speed and torque.</p> <p>Assuming that:</p> <ul> <li>\\(P\\) is power</li> <li>\\(\\tau\\) is torque</li> <li>\\(S\\) is speed</li> </ul> \\[ P=\\tau*S \\] \\[ \\tau=P/S \\] \\[ S=P/\\tau \\] <p>Power is the amount of energy transferred over time. Given a system where power is constant, torque and speed are inversely proportional. This means that the more torque you have, the less speed you have, and vice versa. The easier it is to move your system, the slower you go, and the harder it is to move your system, the faster you go.</p> <p>If you've ever ridden a bike with a gearshift, you've experienced this firsthand. In the lowest gear its very easy to move, but you can't go very fast. As you increase what gear you're in, it becomes much harder to pedal, but you can go much faster.</p>"},{"location":"software/introduction/","title":"Software","text":"<p>Coding is a crucial part of robotics. Building may create robots, but coding is what actually brings life to them. Even if you plan on being a builder, it\u2019s important to know at least some basic coding to be able to familiarize yourself with your team\u2019s code as well as solve simple problems in the absence of a coder. In this section we\u2019ll teach you the general coding knowledge you\u2019ll need to be able to create effective and working programs for robotics.</p>"},{"location":"software/introduction/#programming-mindset","title":"Programming Mindset","text":"<p>Much of programming is creating programs for your team's robot. But it's also much more than that.</p> <p>Being a programmer is about You'll need to work with builders, squad leaders, drivers, notebookers, and even other programmers in order to be successful.</p>"},{"location":"software/introduction/#what-is-programming","title":"What is programming?","text":"<p>In his first lecture for CS50 2022 (Harvard's introductory computer science course, which you can check out for free here), David J. Malan states that computer science is \"all about information and...the solving of problems.\" This problem-solving process essentially boils down to the following diagram:</p> <pre><code>graph LR;\n    A(Input)--&gt;B(Program);\n    B--&gt;C(Output);</code></pre> <p>As a programmer, your main job is to make a Program that takes in information (Input) and does something with it to produce a desirable outcome (Output). Here's how this would work with drive code.</p> <ol> <li>Input: The inputs are the joystick values sent from the controller to the robot.</li> <li>Program: Code that takes the joystick inputs and uses them to send commands to the robot.</li> <li>Output: The robot moves as the driver intended.</li> </ol> <p>You'll want to keep all three of these steps in mind when you're programming. Make sure you have all the sensors and peripherals you need for your Inputs. Then, find out how to use those inputs in your Program to perform some kind of action (Output).</p>"},{"location":"software/introduction/#programming-tips","title":"Programming Tips","text":"<ul> <li>Communicate with your driver: Consult your team's driver on how they want to operate the robot using the controller. Design usercontrol code with their preferences in mind.<ul> <li>Furthermore, try to make their life as easy as possible during matches to give them an edge over other teams. Are there any difficult tasks that you can automate for them for more reliable scoring?</li> </ul> </li> <li>Communicate with your builders and team leader: Work with your team to ensure that your bot has all the sensors you need for your program, and if you need sensors organized in a specific manner, let them know ahead of time so they can account for that in their design.<ul> <li>Don't be afraid to do some mechanical work, either! If you're asked to help with building the robot, lend an extra pair of hands. This can not only speed up the build process, but also give you a better feel for the robot you are programming for and its potential capabilities and limitations included.</li> </ul> </li> </ul>"},{"location":"software/introduction/#further-reading","title":"Further Reading","text":"<p>This is the baseline that you will need to program for robotics, but we highly recommend that you read through some other tutorials. We recommend this one.</p>"},{"location":"software/advanced-concepts/bang-bang/","title":"Bang Bang Controller","text":"<p>The bang bang controller is one of the most basic control loops you can use. It's a feedback controller which means that it responds to the current state of the system. With this controller, there are only two outputs, on, and off.</p> <pre><code>float error = calculateError(); // Error is the distance away from the point you want to reach.\n\nwhile (true) {\nerror = calculateError();\nif (error &gt; 0)\nchassis.move(127); // Move the chassis forward at max speed\n} else {\nchassis.move(0); // Stop the chassis\n}\n}\n</code></pre> <p>In this case, the while loop would run until the system hits the target, in this case the drivetrain. Generally you would not use a bang bang controller for autonomous drivetrain movement because you usually overshoot your target, however for some systems you don't need any more precision then bang bang.</p>"},{"location":"software/advanced-concepts/boomerang/","title":"Boomerang Controller","text":"<p>Prerequisite knowledge:</p> <ul> <li>trigonometry</li> </ul> <p>The boomerang controller isn't really a controller, although the VEX community calls it that. The boomerang controller is a method of moving the bot to a point on the field. It also lets you specify the absolute rotation the bot will end up in. This is 2D motion, so it requires odometry to function. The boomerang controller actually uses a PID controller underneath to get to it's target.</p>"},{"location":"software/advanced-concepts/boomerang/#theory","title":"Theory","text":"<p>The algorithm doesn't actually have the robot move to the target point, it has it move it an intermediate carrot point. As the robot gets closer to the carrot point, the carrot point moves closer to the target point. This causes the robot to move towards the target.</p> <p> </p> In this example, the bot is moving to (0,0) and will end with a rotation of 0 degrees."},{"location":"software/advanced-concepts/boomerang/#math","title":"Math","text":"<p>The math to calculate the carrot point is pretty simple.</p> <p>First we calculate the distance between the start point and the end point.</p> <p>The following variables are used:</p> <ul> <li>\\(h\\) is the distance between the start point and end point.</li> <li>\\(x_{start}\\) is the x coordinate of the current position of the robot.</li> <li>\\(y_{start}\\) is the y coordinate of the current position of the robot.</li> <li>\\(x_{end}\\) is the x coordinate of the target position.</li> <li>\\(y_{end}\\) is the y coordinate of the target position.</li> <li>\\(x_{carrot}\\) is the x coordinate of the carrot point.</li> <li>\\(y_{carrot}\\) is the y coordinate of the carrot point.</li> <li>\\(d_{lead}\\) is the gain that controls how far the carrot point is away from the end point. Can be a value between 0 and 1.</li> </ul> \\[ h=\\sqrt{x_{start}-x_{end}+y_{start}-y_{end}} \\] <p>Then we calculate x the coordinate of the carrot point by subtracting the y component of \\(h\\) from \\(x_{end}\\)</p> \\[ x_{carrot}=x_{end}-h\\sin(\\theta_{end})*d_{lead} \\] <p>And we calculate y the coordinate of the carrot point by subtracting the x component of \\(h\\) from \\(x_{end}\\)</p> \\[ y_{carrot}=y_{end}-h\\cos(\\theta_{end})*d_{lead} \\]"},{"location":"software/advanced-concepts/boomerang/#implementation","title":"Implementation","text":"<p>This algorithm doesn't provide any actual movement control, so we'll use PID. You'll need to PID controllers, one for the linear movement, and one for the rotational movement. There is more information on how to move to 2D points here.</p> <p>The carrot point changes over time, so a control loop is required. Every time the loop runs you'll need to:</p> <ol> <li>Get the current position of the robot.</li> <li>Calculate the new carrot point.</li> <li>Calculate the linear error from the robot to the carrot point.</li> <li>Get the output of the linear PID controller.</li> <li>Calculate the rotational error from the robot to the carrot point.</li> <li>Get the output of the rotational PID controller.</li> <li>Move the motors with the outputs of the controllers.</li> </ol> <p>Here is some pseudocode for that loop:</p> <pre><code>class Point {\npublic:\nfloat x;\nfloat y;\nfloat theta;\n\nPoint(float x, float y, float theta) {\nx = x;\ny = y;\ntheta = theta;\n}\n\nfloat getLinearDist(Point other) {\nreturn std::hypot(this-&gt;x - other.x, this-&gt;y - other.y);\n}\n\n};\n\nbool atTarget;\nfloat lead = 0.5;\n\nwhile (!atTarget) {\nPoint target(10, 10, 90);\nPoint currentPosition = getCurrentPosition(); // Get current position from odometry\n\nPoint carrotPoint = Point(\n(target.x - distance * sin(target.theta) * lead),\n(target.y - distance * cos(target.theta) * lead),\n0.0);\n\n// Movement code ...\n\n}\n</code></pre>"},{"location":"software/advanced-concepts/control-loops/","title":"Control Loops","text":"<p>Control loops are the fundamental part of overall control theory. A control loop brings a system to a target. This can be any system, a thermostat, a car, or even a robot. The target can be anything, the temperature of the system, the position of the system, or even the velocity of the system. As long as there is a way to affect the system, and a desired target, you can apply a control loop. There are two major variants of control loops: open loop control and closed loop control.</p>"},{"location":"software/advanced-concepts/control-loops/#open-loop-control","title":"Open Loop Control","text":"<p>In this variant, also known as feedforward control, the loop does not react to the state of the system. A good example of this is the driver controlling the robot. In this case, the robot is the system, and the robot's position is the state of the loop. The driver knows where they want the robot to go (the target), and moves the robot accordingly. In this scenario, the robot is not adjusted based on it's current position, it's adjusted based on the input from the driver. The code is never aware of the robot's position. Here is a visualization of open loop control:</p> <p></p> <p>As you can see here, The loop doesn't check the state of the system, it just outputs directly.</p>"},{"location":"software/advanced-concepts/control-loops/#closed-loop-control","title":"Closed Loop Control","text":"<p>In this variant, also known as feedback control, responds to the state of the system. A good example of this is a thermostat. The thermostat brings the room to a target temperature. It gets the current temperature, and if the current temperature is too low, it will start heating, but if the temperature it too high, it will stop. Here is a visualization of closed loop control:</p> <p></p>"},{"location":"software/advanced-concepts/introduction/","title":"Advanced Concepts","text":"<p>The concepts in this section aren't required to make a functioning robot, but they can make your robot extremely efficient and precise, a must if you want to make large scale autonomous routines.</p>"},{"location":"software/advanced-concepts/introduction/#control-theory","title":"Control Theory","text":"<p>From Wikipedia:</p> <p>Control theory is a field of control engineering and applied mathematics that deals with the control of dynamical systems in engineered processes and machines. The objective is to develop a model or algorithm governing the application of system inputs to drive the system to a desired state, while minimizing any delay, overshoot, or steady-state error and ensuring a level of control stability; often with the aim to achieve a degree of optimality.</p> <p>If you are moving your robot, control theory is something to take into consideration. This can be applied anywhere where you have control over a system, and a way to measure it's position. This section covers multiple controllers that can be used to move a system in just the right way, from primitive bang bang controllers, to PID, TBH, and FeedForward controllers.</p>"},{"location":"software/advanced-concepts/introduction/#position-tracking","title":"Position Tracking","text":"<p>You cannot apply control theory if you don't have reliable data on the location of your robot. There are numerous methods to tracking your robot, from 1 dimensional distance, to full field position tracking with odometry.</p>"},{"location":"software/advanced-concepts/move-to-point/","title":"Moving to 2D Points","text":""},{"location":"software/advanced-concepts/move-to-point/#theory","title":"Theory","text":"<p>Odometry lets you visualize the robot in 2D space, however this isn't very useful without a way to traverse that 2D Space. There are many ways to solve this problem, but the simplest way is to use PID. We can use two PID controllers to move the robot. One controller will move the bot towards the point, and the other one will rotate the bot to face the point.</p>"},{"location":"software/advanced-concepts/move-to-point/#math","title":"Math","text":"<p>In order to use PID, we first need error. We have two PID loops, so we'll need to different error values, one for the linear error, and one for the rotational error.</p>"},{"location":"software/advanced-concepts/move-to-point/#rotational-error","title":"Rotational Error","text":"<p>This is the amount of degrees between the facing of the robot, and the target point.</p> <p></p> <p>Assuming these variables:</p> <ul> <li>\\(\\Delta x\\) is the change in x coordinate from the current point to target point.</li> <li>\\(\\Delta y\\) is the change in y coordinate from the current point to the target point.</li> <li>\\(e_{rotational}\\) is the rotational error, in radians.</li> <li>\\(\\theta_{current}\\) is the current rotation of the robot relative to the field, in radians.</li> </ul> \\[ e_{rotational}=\\theta_{current}-atan2(\\Delta y,\\Delta x) \\]"},{"location":"software/advanced-concepts/move-to-point/#linear-error","title":"Linear Error","text":"<p>While this seems like it should just be as simple as using the distance formula, it isn't. PID loops are only concerned with the error they can correct for. We want to find the distance that the robot has to travel in order to get us as close as possible to the target point without turning. If we get the actual distance, the error might actually increase as the robot moves, causing a negative feedback loop.</p> <p></p> <p>Assuming these variables:</p> <ul> <li>\\(\\Delta x\\) is the change in x coordinate from the current point to target point.</li> <li>\\(\\Delta y\\) is the change in y coordinate from the current point to the target point.</li> <li>\\(e_{linear}\\) is the linear error.</li> <li>\\(e_{rotational}\\) is the rotational error, in radians.</li> </ul> \\[ e_{linear}=\\sin(e_{rotational})*\\sqrt{\\Delta x + \\Delta y} \\]"},{"location":"software/advanced-concepts/move-to-point/#implementation","title":"Implementation","text":"<p>This will only cover calculating error, since PID was already covered here.</p> <pre><code>class Point {\npublic:\nfloat x;\nfloat y;\nfloat theta;\n\nPoint(float x, float y, float theta = 0) {\nx = x;\ny = y;\ntheta = theta;\n}\n};\n\nPoint targetPoint(10, 10);\n\nwhile (true) {\nPoint currentPosition = getCurrentPosition(); // Get position from odometry\n\n// update error\nfloat deltaX = targetPoint.x - currentPosition.x;\nfloat deltaY = targetPoint.y - currentPosition.y;\nfloat targetTheta = fmod(radToDeg(M_PI_2 - atan2(deltaY, deltaX)), 360);\nfloat hypot = std::hypot(deltaX, deltaY);\nfloat diffTheta1 = angleError(currentPosition.theta, targetTheta);\nfloat diffTheta2 = angleError(currentPosition.theta, targetTheta + 180);\nfloat angularError =\n(std::fabs(diffTheta1) &lt; std::fabs(diffTheta2)) ? diffTheta1 : diffTheta2;\nfloat lateralError = hypot * cos(degToRad(std::fabs(diffTheta1)));\n\n// Do PID computations ...\n\n// Move the motors\nleftPower = linearPidOutput - rotationalPidOutput;\nrightPower = linearPidOutput + rotationalPidOutput;\n\nleftMotors.move(leftPower);\nrightMotors.move(rightPower);\n}\n</code></pre> <p>Note</p> <p>Rotational error can very quickly change if the robot crosses the target point. This can cause the robot to spin in circles. You will need to implement something to handle what happens when the robot is near the target.</p>"},{"location":"software/advanced-concepts/odometry/","title":"Odometry","text":"<p>Prerequisite Mathematical Knowledge:</p> <ul> <li>algebra</li> <li>trigonometry</li> </ul> <p>Odometry lets you track the position of the robot in 2D space, using Cartesian coordinates. This method of tracking was popularised by team 5225, the Pilons. If you want to read more about how to derive the math behind odometry, you should read their guide.</p>"},{"location":"software/advanced-concepts/odometry/#theory","title":"Theory","text":"<p>Odometry is a very useful tool. It provides the absolute position of your robot's tracking center in 2D space. The location of the tracking center is dictated by the placement of your tracking wheels (see below). This means that you can account for error that is created during movement. If one of the movements of your bot is off, the next movement will correct for that, as long as you tell your bot to move to absolute positions on the field.</p> <p>That being said there are some limitations. Odometry can often drift, which can lead to small error that builds up over time. Teams often solve this problem by aligning their robot against a wall, and then resetting the robot's position in the odometry.</p>"},{"location":"software/advanced-concepts/odometry/#hardware-prerequisites","title":"Hardware Prerequisites","text":"<p>Your robot needs some way to track its position. This can be achieved in multiple ways. The main things you need are:</p> <ul> <li>a way to track the robot's movement forwards and backwards</li> <li>a way to track the robot's movement side to side</li> <li>a way to track the robot's rotation</li> </ul> <p>Typically this is done with passive tracking wheels. These are wheels that are directly attached to an encoder that tracks their position. Below is a typical tracking wheel:</p> <p> </p> Credit to LemLib for this image <p>Usually you need three of them, two parallel to each other, and one perpendicular. The two parallel provide forwards and backwards tracking, as well as rotation, while the perpendicular one provides side to side movement. You can also use an IMU Sensor in the place of one of the parallel tracking wheels.</p> <p>While you could just use the integrated motor encoders, it is usually not advised, because of wheels slipping, and gear slop. Sensors get less accurate the farther away they are from what they're tracking, that's just a fact of life.</p> <p>The position of your tracking wheels dictates your tracking center.</p> <p> </p> Credit to LemLib for this image"},{"location":"software/advanced-concepts/odometry/#math","title":"Math","text":"<p>First we need to define some variables:</p> <ul> <li>\\(s_L\\) is the distance from the left tracking wheel to the tracking center.</li> <li>\\(s_R\\) is the distance from the right tracking wheel to the tracking center.</li> <li>\\(s_S\\) is the distance from the center tracking wheel to the tracking center.</li> </ul> <p>Odometry is the compound change in position of the robot over time. Essentially, the final position can be calculated as the sum of all of the movements up to that point. The move often the change in position is calculated, the more accurate the position is.</p> <p></p> <p>The first thing that needs to be calculated is the rotation of the robot. This can be calculated like this:</p> \\[ \\Delta\\theta=\\frac{\\Delta L-\\Delta R}{s_L+s_R} \\] <p>The function is only concerned with the difference between \\(\\Delta R\\) and \\(\\Delta L\\), so we can use the total distance the wheels have traveled to find the current absolute orientation.</p> <p>Now we need a way to calculate the distance the robot has actually traveled. The first thing we need is a local coordinate system. This is a temporary coordinate plane that assumes that we use as an in between step every time we need to calculate the distance the robot has moved. This local coordinate system assumes that the robot's starting position is \\((0,0)\\).</p> <p>The local y coordinate is the distance tracked by the left or right tracking wheel.</p> <p></p> <p>The local x coordinate is the distance tracked by the center tracking wheel</p> <p></p> <p>If the change in rotation is zero, the distance traveled is simply equal to the distance the tracking wheels have traveled.</p> \\[ \\Delta Y_{local}=\\Delta L \\] \\[ \\Delta X_{local}=\\Delta S \\] <p>However, if the robot turned while making it's movement, the calculation becomes more complicated.</p> <p></p> <p>As you can see in the image above, the actual distance traveled by the robot is not equal to the arc length that the wheels create. We can calculate the actual distance by using this formula:</p> \\[ \\Delta X_{local}=2\\sin{\\frac{\\theta}{2}}*\\left(\\frac{\\Delta S}{\\Delta \\theta}+s_S\\right) \\] \\[ \\Delta Y_{local}=2\\sin{\\frac{\\theta}{2}}*\\left(\\frac{\\Delta L}{\\Delta \\theta}+s_L\\right) \\] <p>We then need to calculate the average rotation of the robot.</p> \\[ \\theta_m=\\theta_0\\frac{\\Delta\\theta}{2} \\] <p>Now we need to convert these local coordinates to the change in global coordinates (the actual position of the robot). We can use the average rotation to get the x and y components of the local x coordinate and the local y coordinate.</p> \\[ \\Delta X_{global}=\\Delta X_{local}*sin(\\theta_m)-\\Delta Y_{local}*cos(\\theta_m) \\] \\[ \\Delta Y_{global}=\\Delta X_{local}*cos(\\theta_m)-\\Delta Y_{local}*sin(\\theta_m) \\]"},{"location":"software/advanced-concepts/odometry/#implementation","title":"Implementation","text":"<p>Odometry usually runs in an infinite loop, for the duration of the program. Usually you would put it in its own task, so that it can run concurrently to the main program.</p> <p>Every time this loop runs, you need to do these things:</p> <ol> <li>Store the values of the encoders in variables. <pre><code>leftPosition = getLeftEncoderValue(); // Returns the distance the encoder has traveled, in degrees.\nrightPosition = getRightEncoderValue();\nperpendicularPosition = getPerpendicularEncoderValue();\n</code></pre></li> <li>Calculate the change in encoder values since the last loop, and then convert that value into distance traveled. The units of this variable will be whatever the units of WHEEL_RADIUS are, usually inches. <pre><code>deltaLeft = (leftPosition - prevLeftPosition) * (M_PI / 180) * WHEEL_RADIUS; // Convert degrees to radians\ndeltaRight = (rightPosition - prevRightPosition) * (M_PI / 180) * WHEEL_RADIUS; // You can omit this if you have an IMU\ndeltaPerpendicular = (perpendicularPosition - prevPerpendicularPosition) * (M_PI / 180) * WHEEL_RADIUS;\n</code></pre></li> <li>Update the previous values of the encoders. <pre><code>prevLeftPosition = leftPosition;\nprevRightPosition = rightPosition;\nprevPerpendicularPosition = perpendicularPosition;\n</code></pre></li> <li>Calculate total distance traveled for each encoder. If you have an IMU you can skip this step. <pre><code>totalDeltaLeft += deltaLeft;\ntotalDeltaRight += deltaRight;\ntotalDeltaPerpendicular += deltaPerpendicular;\n</code></pre></li> <li>Calculate the current absolute orientation of the robot. This is the offset of the robot from the field. If you're using parallel tracking wheels: <pre><code>// TRACKING_WIDTH is the distance between the two tracking wheels in inches\ncurrentAbsoluteOrientation = (totalDeltaLeft - totalDeltaRight) / (TRACKING_WIDTH);\n</code></pre> If you have an IMU: <pre><code>currentAbsoluteOrientation = getImuHeading() * M_PI / 180; // Convert degrees to radians\n</code></pre></li> <li>Calculate deltaTheta (change in rotation). <pre><code>deltaTheta = currentAbsoluteOrientation = prevTheta;\nprevTheta = currentAbsoluteOrientation;\n</code></pre></li> <li>Now we get to the hard part. We now have to calculate local offset. This is the distance the robot has traveled relative to its rotation. If deltaTheta is zero, the robot moved in a perfectly straight line. This distinction is mainly to prevent division by zero. <pre><code>deltaXLocal = deltaPerpendicular;\ndeltaYLocal = deltaLeft;\n</code></pre> If deltaTheta is any other value, we calculate local coordinates like this: <pre><code>// LEFT_TRACKING_RADIUS is the distance from the left tracking wheel to the tracking center of the robot\n// PERPENDICULAR_TRACKING_RADIUS is the distance from the perpendicular tracking wheel to the tracking center of the robot\n\ndeltaXLocal = 2 * sin(deltaTheta) * ((deltaPerpendicular / deltaTheta) + PERPENDICULAR_TRACKING_RADIUS);\n\ndeltaYLocal = 2 * sin(deltaTheta) * ((deltaLeft / deltaTheta) + LEFT_TRACKING_RADIUS);\n</code></pre></li> <li>Calculate the average angle for this loop. <pre><code>avgTheta = currentAbsoluteOrientation - (deltaTheta / 2);\n</code></pre></li> <li>Calculate the change in global coordinates. This is done by taking the x and y components of the local coordinates. <pre><code>deltaXGlobal = (deltaYLocal * cos(avgTheta)) -\n(deltaXLocal * sin(avgTheta));\n\ndeltaYGlobal = (deltaYLocal * sin(avgTheta)) -\n(deltaXLocal * cos(avgTheta));\n</code></pre></li> <li>Check to see if your angles are under zero, or over 2\\(\\pi\\) (360 degrees), and wrap them if they are. <pre><code>while (currentAbsoluteOrientation &gt;= 0) {\ncurrentAbsoluteOrientation -= 2 * M_PI;\n}\n\nwhile (currentAbsoluteOrientation &lt; 0) {\ncurrentAbsoluteOrientation += 2 * M_PI;\n}\n</code></pre></li> <li>Update the global coordinates. The global coordinates are the actual Cartesian coordinates of your robot. <pre><code>currentXPosition += delta_x_global;\ncurrentYPosition += delta_y_global;\ncurrentTheta = current_absolute_orientation;\n</code></pre></li> </ol> <p>Note</p> <p>This implementation assumes that the starting point of the robot is \\((0,0)\\). It is recommended that to offset the starting position of the robot in the code so that the coordinates for items of interest the same. For example, if there  is a game piece at \\((10,10)\\), you wouldn't want the starting position of your robot to affect the position in the code of the game piece. Choose a point on the field, and make that your origin. Usually, people use either the bottom left corner, or the direct center of the field.</p> <p>If you want to look at a full implementation you can fine one here.</p>"},{"location":"software/advanced-concepts/pid/","title":"PID Controller","text":""},{"location":"software/advanced-concepts/pid/#history","title":"History","text":"<p>From Wikipedia:</p> <p>It was not until 1922, however, that a formal control law for what we now call PID or three-term control was first developed using theoretical analysis, by Russian American engineer Nicolas Minorsky. Minorsky was researching and designing automatic ship steering for the US Navy and based his analysis on observations of a helmsman. He noted the helmsman steered the ship based not only on the current course error but also on past error, as well as the current rate of change; this was then given a mathematical treatment by Minorsky. His goal was stability, not general control, which simplified the problem significantly. While proportional control provided stability against small disturbances, it was insufficient for dealing with a steady disturbance, notably a stiff gale (due to steady-state error), which required adding the integral term. Finally, the derivative term was added to improve stability and control.</p> <p>Trials were carried out on the USS New Mexico, with the controllers controlling the angular velocity (not the angle) of the rudder. PI control yielded sustained yaw (angular error) of \u00b12\u00b0. Adding the D element yielded a yaw error of \u00b11/6\u00b0, better than most helmsmen could achieve.</p>"},{"location":"software/advanced-concepts/pid/#theory","title":"Theory","text":"<p>PID controller can be used anywhere a bang bang controller could be used. Similar to the bang bang controller, it uses closed loop control to adapt to interference. They are very precise, and are the bread and butter of autonomous movement. The fundamental difference between a bang bang controller and a PID controller is that the output varies based on the proximity to the target. The PID controller has a lower output as the system moves close to the target. This makes it much better than the bang bang controller, which assumes that the system can go from maximum speed to halted instantly.</p> <p></p> <p>PID stands for proportional, integral, derivative. These are the three components of the loop. These not all required. As long as your loop has the proportional term, it will function.You can make a loop with:</p> <ul> <li>P</li> <li>PI</li> <li>PD</li> <li>PID</li> </ul>"},{"location":"software/advanced-concepts/pid/#math","title":"Math","text":"<p>Assuming these variables:</p> <ul> <li>\\(p\\) is the proportional term</li> <li>\\(i\\) is the integral term</li> <li>\\(d\\) is the derivative term</li> <li>\\(k_p\\) is the proportional gain</li> <li>\\(k_i\\) is the integral gain</li> <li>\\(k_d\\) is the derivative gain</li> <li>\\(o\\) is the output of the loop</li> <li>\\(s_{target}\\) is the target state</li> <li>\\(s_{current}\\) is the current state</li> </ul> <p>The output of the controller is equal to all of the terms multiplied by their respective constants, added together.</p> \\[ o=p*k_p+i*k_i+d*k_d \\]"},{"location":"software/advanced-concepts/pid/#proportional","title":"Proportional","text":"<p>The proportional is the core of the PID loop. It is simply equal to error (the distance from the target). As the system gets close to the target, error decreases. If the system passes the target, error is negative, meaning the system will travel back to the target.</p> <p></p> <p>We can calculate proportional as the target state subtracted by the current state:</p> \\[ p=s_{target}-s_{current} \\]"},{"location":"software/advanced-concepts/pid/#integral","title":"Integral","text":"<p>If we imagine the error over time on a graph, the integral is the area under the line of error. We can think of integral as the total compound error over time.</p> <p></p> <p>We can calculate integral like this:</p> \\[ i=i+p \\] <p>By adding the current error to the current value of integral each time the loop runs, we can get the total compounded error.</p> <p>Note</p> <p>This is not exactly equal to the area under the graph, but this is as close of an approximation as we can achieve.</p> <p>The integral serves to correct for larger interferences that the proportional term cannot. If the system gets stuck, integral will build up, and gradually increase the output.</p>"},{"location":"software/advanced-concepts/pid/#derivative","title":"Derivative","text":"<p>The derivative is the rate of change at the current point in the graph. To get the derivative we need two points on the graph.</p> <p></p> <p>We can calculate the derivative by getting the two closest points on the graph possible, the current error, and the error during the previous iteration of the loop:</p> \\[ d=p-p_{prev} \\] <p>Note</p> <p>This is not how a derivative is normally calculated, but this is as close of an approximation as we can achieve.</p> <p>The derivative term predicts what the output needs to be based on the current state of the system. If the system is accelerating really quickly, the absolute value of derivative will become larger. The sign of the derivative term is always inverse to the direction that the system is moving to the target. This means that if the system is moving towards the target, derivative will be negative, and if the system is moving back to the target, derivative will be positive. This means that derivative serves to dampen the output of the controller. If the system is accelerating too quickly, derivative will compensate by getting larger. If the system is moving too slowly, derivative will compensate by getting smaller.</p>"},{"location":"software/advanced-concepts/pid/#implementation","title":"Implementation","text":""},{"location":"software/advanced-concepts/pid/#terms","title":"Terms","text":"<pre><code>float distTraveled = 0;\nfloat target = 12; // We want to move 12 inches forward\nfloat error = target;\nfloat output;\nfloat totalError;\nfloat derivative;\nfloat prevError;\n\nwhile (true) {\ndistTraveled = getDistanceTraveled(); // Returns the distance traveled in inches\n\nerror = target - distTraveled; // Proportional term\n\nintegral += error;\n\nderivative = error - prevError;\nprevError = error;\n\noutput = error + integral + derivative;\nchassis.move(output);\npros::delay(10); // Delay for 10 ms\n}\n</code></pre> <p>We also need to prevent integral windup. Integral is only relevant if the error is close to zero. If error is large, integral can grow very quickly and become unusable. We can add an if statement to solve this problem.</p> <pre><code>if (error &gt; hugeError) {\nintegral = 0;\n}\n</code></pre> <p>Note</p> <p>getDistanceTraveled() is not a real function. Replace it with your own code that calculates the distance the robot has traveled.</p>"},{"location":"software/advanced-concepts/pid/#gains","title":"Gains","text":"<p>However, there is still one major problem: The output of this loop does not match what the methods of the motor expect as input. We can solve this problem with gains. These are constants that are multiplied with each term. Each term has it's own constant. These are set by you, and need to be tuned manually.</p> <pre><code>float kP = 10;\nfloat kI = 0; // This would disable the integral\nfloat kD = 30;\n\nwhile (true){\n\n// ...\n\noutput = error * kP + integral * kI + derivative * kD;\n}\n</code></pre> <p>Keep in mind that these constants depend on the units of your input and ouput.</p>"},{"location":"software/advanced-concepts/pid/#tuning","title":"Tuning","text":"Credit to Wikipedia <p>Tuning is often the hardest part of PID. Follow these steps, and you'll be able to get something reasonably precise.</p> <ol> <li>Set all of your constants to zero. This will effectively disable the loop.</li> <li>Increase kP until the system overshoots and moves back and forth around the target.</li> <li>Increase kD until the system doesn't oscillate around the target anymore.</li> </ol> <p>Whether you want an I term usually depends on whether your system is trying to maintain it's position, in which case you do want I, or if your loop is exiting as soon as you hit the target, in which case you don't.</p> <ol> <li>Adjust kI until your system gets as close to the target as possible.</li> </ol>"},{"location":"software/advanced-concepts/pid/#exit-conditions","title":"Exit Conditions","text":"<p>If your system is something like a drivetrain, you probably want to exit the loop once you hit the target. However, this may be trickier than you would think. We could just do this:</p> <pre><code>while (error &gt; 0) {\n// compute the loop\n}\n</code></pre> <p>While this seems like it should work, it has some problems. This would exit instantly, as soon as error is passed. If the system is overshooting, this will have the same issues as bang bang. A more elegant solution is to require the system to be within a target range for a certain amount of time.</p> <pre><code>// Variable definitions\n\n// Time elapsed since the start of the program in milliseconds\nstartTime = getCurrentTime();\nwhile (true) {\n\n// ...\n\n// Max time is nice to have if your system gets stuck\nif (getCurrentTime() - startTime &gt; timeout) {\nbreak;\n}\n\nif (std::fabs(prevError) &lt; acceptableError) {\nif (!timeAtTarget)\ntimeAtTarget = getCurrentTime();\nelse if (getCurrentTime() - timeAtTarget &gt; settleTime)\nbreak;\n}\n}\n</code></pre> <p>Note</p> <p>getCurrentTime() is not a real function. Replace it with the equivalent function call for the API you are using.</p> <p>If you want to look at a complete implementation of PID you can find it here.</p>"},{"location":"software/advanced-concepts/pid/#further-reading","title":"Further Reading","text":"<p>George Gillard - Intro to PID</p>"},{"location":"software/basics/control-flow/","title":"Control Flow","text":"<p>Normally our code runs from top to bottom. However, sometimes we don't want it to. This is where control flow comes into play. These are pieces of code that let us control the flow of the program, hence their name.</p> <p>I\u2019d recommend checking out this link if you want to look at more information about control flow.</p>"},{"location":"software/basics/control-flow/#if-else-if-else","title":"If, Else if, Else","text":"<p>If, else if, and else statements are great for allowing us to control the flow of a program. They\u2019re the bread and butter of your robot\u2019s code.</p>"},{"location":"software/basics/control-flow/#if-statement","title":"If statement:","text":"<p>If statements follow this structure if (condition) statement if - The keyword that indicates the creation of an if statement condition - A boolean condition in parentheses (evaluates to true or false) statement - The code you want to run Comparison operators are particularly useful for conditional statements. For example, you could have an if statement like this:</p> <pre><code>bool inRestPos = false;\nif (degrees &gt;= 45) {\ninRestpos = true;\n}\n</code></pre> <p>The boolean variable inRestPos would only be set to true if the variable degrees was greater than or equal to 45.</p> <p>However, sometimes we want more than one code statement to run under an if-statement. We do this through the use of curly brackets ( {} ). We can put several code statements under curly brackets under an if-statement to tell the code that we want all statements in there to be run if the condition is true.</p> <pre><code>if (L1) {\nintake.move(127); // We'll go over what this means later\n}\n</code></pre>"},{"location":"software/basics/control-flow/#else-if-statement","title":"Else if statement:","text":"<p>Else if statements follow a similar structure to if statements:</p> <pre><code>else if (condition) statement\n</code></pre> <p>Else if statements follow an if statement and run only if the statement before it evaluates as false.</p> <pre><code>if (count == 0) {\natRest = true;\n} else if (count == 1) {\natRest = false;\n}\n</code></pre> <p>In the example above, the else if statement only runs if count is not equal to 0.</p> <p>You can also chain else if statements together.</p> <pre><code>if (count == 0) {\narmAngle = 0;\n} else if (count == 1) {\narmAngle = 30;\n} else if (count == 2) {\narmAngle = 60;\n} else if (count == 3) {\narmAngle = 90;\n}\n</code></pre>"},{"location":"software/basics/control-flow/#else-statement","title":"Else statement:","text":"<p>Else statements follow this structure:</p> <pre><code>else statement\n</code></pre> <p>Note that they do not need a condition. That is because else statements run automatically if the statement above evaluates as false.</p> <pre><code>if (count == 0) {\natRest = true;\n} else {\natRest = false;\n}\n</code></pre> <p>The code under the else statement will run automatically if the if statement above it is false.</p> <p>Note that else statements can follow a chain of if and else if statements as a final condition.</p> <p>Note</p> <p>you don\u2019t have to be concerned with what this code means, this is just an example used to show a use of the else statement.</p> <pre><code>if (L1) {\nintake.move(127);\n} else if (L2) {\nintake.move(-127);\n} else {\nintake.move(0);\n}\n</code></pre>"},{"location":"software/basics/control-flow/#switch-statement","title":"Switch statement","text":"<p>Switch statements are a good way to control the flow of your code when you have many different \u2018cases\u2019 you may be trying to test. They follow this structure:</p> <pre><code>switch (value) {\ncase x:\n// code here\nbreak;\ncase y:\n// code here\nbreak;\ncase z:\n// code here\nbreak;\n\n//...as many cases as you need\n\n// optional catch-all statement\ndefault:\n// code here\nbreak;\n}\n</code></pre> <p>A switch statement will take a value you give it and test it against several different cases. If the value is equal to a certain case, then that case\u2019s code will be run. Let\u2019s look at an example.</p> <pre><code>switch (autonChoice) {\ncase 0:\nonePoint();\nbreak;\ncase 1:\nredUnsafe();\nbreak;\ncase 2:\nredSafe();\nbreak;\ncase 3:\nblueUnsafe();\nbreak;\ncase 4:\nblueSafe();\nbreak;\ndefault:\nonePoint();\nprintf(\"Error in auton choice\\n\");\nbreak;\n}\n</code></pre> <pre><code>if (autonChoice == 0) {\nonePoint();\n} else if (autonChoice == 1) {\nredUnsafe();\n} else if (autonChoice == 2) {\nredSafe();\n} else if (autonChoice == 3) {\nblueUnsafe();\n} else if (autonChoice == 3) {\nblueSafe();\n} else {\nonePoint();\nprintf(\"Error in auton choice\\n\");\n}\n</code></pre> <p>Here, you are checking the autonChoice variable against several different cases in the switch statement. (in this case autonChoice is an integer value.)</p> <ul> <li>If autonChoice is equal to 0, the code will run the onePoint() function.</li> <li>f autonChoice is equal to 1, redUnsafe() will be run.</li> <li>If autonChoice is equal to 2, redSafe() will be run.</li> <li>If autonChoice is equal to 3, blueUnsafe() will be run.</li> <li>If autonChoice is equal to 4, blueSafe() will be run.</li> <li>If autonChoice isn\u2019t equal to any of the cases, run the code under default.</li> </ul> <p>Note that the break statements just tell the code to exit from the switch statement after a case is run. Make sure you include these, your code may not work properly without them! The code above can also be represented through if, else if, and else statements as shown.</p>"},{"location":"software/basics/control-flow/#while-loop","title":"While loop","text":"<p>While loops let you repeat a section of code for as long as its condition is fulfilled. They follow this structure:</p> <pre><code>while (expression) statement\n</code></pre> <ul> <li>while - The keyword that indicates the creation of a while loop.</li> <li>expression - a boolean (true or false) condition in parentheses</li> <li>statement - The code you want to run</li> </ul> <p>Here\u2019s an example of a while loop that runs 5 times. Don't worry about what printf does, just know that it will print to the console when called. We'll go over printing to standard out later.</p> <pre><code>int i = 0;\nwhile (i &lt; 5) {\nprintf(\"%i\\n\", i);\ni++;\n}\n</code></pre> <p>Generally speaking, we don\u2019t use while or for loops as much as we do if statements in robotics, but they\u2019re still handy to be familiar with. Be wary if you use them in the driver control period, because if you add while loops to driver control, they may prevent other important pieces of code from running when they\u2019re supposed to.</p>"},{"location":"software/basics/control-flow/#for-loop","title":"For loop","text":"<p>For loops are similar to while loops, but they run for a specified number of times. In that sense, for loops are better for when you know how many times a section of code should run, while loops are better for when you don\u2019t know how many times a section of code should run.</p> <p>Here\u2019s the structure of a for loop:</p> <pre><code>for (initialization; condition; increase) statement\n</code></pre> <ul> <li>initialization - Initializes loop variable and defines its initial value.</li> <li>condition - What condition the variable must meet in order for the loop to keep running</li> <li>increase - Defines how the variable is changed after each run through the loop.</li> <li>statement - The code you want to run (usually in curly brackets)</li> </ul> <pre><code>for (int i = 0; i &lt; 5; i++) {\n// do something\n}\n</code></pre> <p>Above is an example of a for loop. Notice how there is an initialization statement, condition statement, and increase statement separated by semicolons in the header. Assuming that i is not changed inside the curly brackets, this loop will run 5 times as described below:</p> <ul> <li>i is set to be 0. 0 is less than 5, so the code in the loop runs. i increases by 1.</li> <li>i is 1, 1 is less than 5, so the code in the loop runs. i increases by 1.</li> <li>i is 2, 2 is less than 5, so the code in the loop runs. i increases by 1.</li> <li>i is 3, 3 is less than 5, so the code in the loop runs. i increases by 1.</li> <li>i is 4, 4 is less than 5, so the code in the loop runs. i increases by 1.</li> <li>i is 5, 5 is not less than 5, so the code in the loop does not run. The for loop is finished.</li> </ul> <p>One important thing to note is that the variable you initialize inside the for loop header is destroyed once the loop is over (that is, it cannot be accessed outside the for loop). That is why this code here is invalid.</p> <pre><code>for (int i = 0; i &lt; 5; i++) {\n// do something\n}\ni = 2; // This doesn't work\n</code></pre> <p>Also, note that the variable declared in the for loop header will override any other previous variable with the same name.</p> <p>Here\u2019s one more example of a for loop. It runs 5 times. Can you find out why?</p> <pre><code>for (int j = 0; j &lt;= 9; j+=2 {\n// do something\n}\n</code></pre>"},{"location":"software/basics/enums/","title":"Enumerations","text":"<p>Enumerations are a very useful feature in strongly typed languages like C++. Enumerations are a custom type that can only have a limited number of values. </p> <p>Look at this example:</p> <pre><code>std::String rockPaperScissors(std::String player1, std::String player2) {\n// Logic that compares the two inputs\n}\n</code></pre> <p>This function takes two strings, and compares them using the rules for rock paper scissors. It returns \"player1\" if player 1 won, and it returns \"player2\" if player 2 won. However, there are multiple problems with this. What happens if the function recieves input other than \"rock\", \"paper\", or \"scissors\"? Unless the function checks for edge cases, there will be some kind of runtime error. There is a better solution: Enums.</p>"},{"location":"software/basics/enums/#unscoped-enums","title":"Unscoped Enums","text":"<p>This is how you define an unscoped enum: <pre><code>enum RpsInput {\nRock,\nPaper,\nScissors\n}\n\nenum RpsResult {\nPlayer1Victory,\nPlayer2Victory,\nTie\n}\n</code></pre></p> <p>This enum can be referred to like you would any other datatype. Using this definition we can rewrite our function to look like this: <pre><code>RpsResult rockPaperScissors(RpsInput player1, RpsInput player2) {\n// Logic that compares the two inputs\n}\n</code></pre></p> <p>A function call would look like this: <pre><code>RpsResult result = rockPaperScissors(Rock, Paper); // Result is Player2Victory\n</code></pre></p> <p>This has a couple advantages over using strings. The function no longer needs to handle edge cases, because the input cannot be anything except members of the enum. In addition, this check is now performed at compile time, which means that you will discover incorrect code faster.</p> <pre><code>// Using the enum definition\nrockPaperScissors(Meteor, Paper); // This will not compile\n\n// Using the string definition\nrockPaperScissors(\"Meteor\", \"Paper\"); // This will compile\n</code></pre> <p>Even if the string version checks for edge cases, the check can only happen at runtime. Remember, its best to always get potential errors during compile time, not at runtime.</p>"},{"location":"software/basics/enums/#scoped-enums","title":"Scoped Enums","text":"<p>Scoped enums are vary similar to enums, except they don't bring their members into local scope. This means we cannot refer to them directly.</p> <pre><code>enum class Color {\nRed,\nGreen,\nBlue\n}\n\nColor color = Color::Red;\n\nColor color = Red; // This would not compile\n</code></pre> <p>Notice how we can't refer to Red directly, we have to refer to it in terms of Color, similar to how we would use a namespace.</p>"},{"location":"software/basics/functions/","title":"Functions","text":"<p>Functions are a powerful tool to help your reduce code duplication. They can take input and send output, and run whatever code is inside them whenever they are called. </p> <p>In order to use a function, you must define it first. Function definetions follow this structure: <pre><code>datatype name(inputs) {\n  statements\n}\n</code></pre> By itself, functions definitions don't do anything. They need to be called. Function calls follow this structure: <pre><code>name(inputs);\n</code></pre> This will execute all of the code between the curly braces in the function definition. Primarily, functions input and output data. Function inputs are variables that get copied into the scope of the function. We'll go over what scope means in the next chapter. Functions can also return values. The datatype of that value is indicated by the first part of a function definition. If a function doesn't return a value, it's datatype is void. Here is an example of a function that takes input and sends output:</p> <pre><code>// This function returns an int\nint add( int x, int y) { // Requires two variables as input, of type integer\nreturn x + y; // Returs the two inputs added together.\n}\n\nint main() { // The main function is where the program's execution starts.\nint sum = add(3,4); // Sum is equal to 7\nreturn 0; // The main function must return 0\n}\n</code></pre> <p>In this case, the function add takes two integers as input, and returns another integer. When 3 and 4 are passed into add in the main function their values get assigned to x and y inside of the function call. These variables then get added together, and returned. This makes this function an expression. An expression is anything that returns a value. This means the function can be used anywhere where we would use a normal value. In the example, the returned value is assigned to a variable.</p> <p>Functions can also help your reduce code duplication:</p> <pre><code>printf(\"-------\\n\");\nprintf(\"hello\");\nprintf(\"-------\\n\");\nprintf(\"\\n\");\n\nprintf(\"-------\\n\");\nprintf(\"world!\");\nprintf(\"-------\\n\");\nprintf(\"\\n\");\n// This could be abreviated to\nvoid fancyPrint(std::string input) { // fancyPrint never returns a value, so it's return type is void.\nprintf(\"-------\\n\");\nprintf(\"%s\",input);\nprintf(\"-------\\n\");\nprintf(\"\\n\");\n}\nfancy_print(\"hello\");\nfancy_print(\"world!\");\n</code></pre>"},{"location":"software/basics/headers/","title":"Header Files","text":"<p>Header files are a key part of C++ program organization. Any file with a .h or .hpp file extension is a header file. You can think of them like a menu for what exists in your program. It tells you what's in the dish, but doesn't actually contain the dish itself. In order to understand header files fully, we'll need to cover some other C++ concepts.</p>"},{"location":"software/basics/headers/#declarations-and-definitions","title":"Declarations and Definitions","text":"<p>C++ differentiates between declarations and definitions. Declarations simply contain the signature of a function or variable, and not the functionality or value, while definitions do.</p> <p>Here are some examples of declarations:</p> <pre><code>int number;\n\nint add(int x, int y);\n</code></pre> <p>Here are some examples of definitions:</p> <pre><code>number = 42;\n\nint add(int x, int y) {\nreturn x + y;\n};\n</code></pre>"},{"location":"software/basics/headers/#compilation-phases","title":"Compilation Phases","text":"<p>The C++ compilation process is split up into multiple phases:</p>"},{"location":"software/basics/headers/#preprocessor-phase","title":"Preprocessor Phase","text":"<p>During this phase, preprocessor directives (also called macros) are evaluated. This is any keyword that starts with a #. For example:</p> <pre><code>#include &lt;iostream&gt;\n#define MACRO_CONSTANT 1\n</code></pre> <p>Macros are not valid C++, but they get replaced with C++ during this phase. The compiler will never see them. In this example, the first line will be replaced with the contents of the iostream header, while the second line will replace all instances of MACRO_CONSTANT with 1.</p>"},{"location":"software/basics/headers/#compilation-phase","title":"Compilation Phase","text":"<p>During this phase, body files (files with a .cpp file extension) get turned into object files by the compiler. This converts them from code that the programmer can read into code that a CPU can read. The compiler is completely fine with references definitions that don't exist, so long as there is a valid definition. The compiler will also check for valid C++ grammar.</p>"},{"location":"software/basics/headers/#linking-phase","title":"Linking Phase","text":"<p>During this phase, all of the object files (files ending in .o) are combined into a single binary. Any blank references to declarations are now filled in. The linker also checks for violations of ODR (the One Definition Rule). There can only be one definition for each variable and function.</p>"},{"location":"software/basics/headers/#usage","title":"Usage","text":"<p>Header files contain declarations (not definitions) and can be used to easily import those declarations to any body file that needs them. Here is an example:</p> <p>Imagine there is a file called math.hpp</p> <pre><code>// math.hpp\n\nint add(int x, int y);\nint doMath();\n</code></pre> <p>There are also two body files, math.cpp and main.cpp.</p> <pre><code>// math.cpp\n#include \"math.hpp\"\n\nint add(int x, int y) {\nreturn x + y;\n}\nint doMath() {\nint sum;\nsum += add(1, 2);\nsum += add(3, 4);\nreturn sum;\n}\n</code></pre> <pre><code>// main.cpp\n\n#include &lt;iostream&gt;\n\n#include \"math.hpp\"\n\nint main() {\nstd::cout &lt;&lt; doMath();\nreturn 0;\n}\n</code></pre> <p>In this example, math.hpp provided the declarations, while math.cpp provided the definitions. Note that math.cpp needed to include the math.hpp header to gain access to the declarations. Then, main.cpp can easily get access to doMath() by including the math.hpp header as well.</p> <p>Note</p> <p>The include for the iostream header and the math.hpp header look very different. This is because iostream is part of the standard library. Headers that are part of the standard library do not have a .h or .hpp extension, and are included using  instead of \"header-name\"."},{"location":"software/basics/headers/#header-guards","title":"Header Guards","text":"<p>However, there is a problem. If a header is included more than once, this can result with multiple copies of the same header. During the linking phase this can cause an ODR violation. The solution is header guards.</p> <pre><code>// math.hpp\n#ifndef MATH_HPP // This name  must be unique, otherwise you will cause other headers to be ignored\n#define MATH_HPP\n\nint add(int x, int y);\nint doMath();\n\n#endif\n</code></pre> <p>#ifndef and #endif allow for conditional inclusion. If MATH_HPP is already defined because the header has already been included once the preprocessor will behave as if this file is empty.</p> <p>Alternatively you can use #pragma once, which will have the same effect.</p> <pre><code>// math.hpp\n#pragma once\n\nint add(int x, int y);\nint doMath();\n</code></pre>"},{"location":"software/basics/headers/#best-practice","title":"Best Practice","text":"<p>There are some DOs and DON'Ts when it comes to header files:</p> <ul> <li>always use header guards</li> <li>never put definitions in headers (with the exception of constants)</li> <li>use one body file per header file (i.e. math.hpp and math.cpp)</li> <li>never #include .cpp files</li> </ul>"},{"location":"software/basics/headers/#further-reading","title":"Further Reading","text":"<p>If you want more information this tutorial provides much more in depth information on header files.</p>"},{"location":"software/basics/namespaces/","title":"Namespaces","text":"<p>These are a powerful tool for project organization. These allow you to put your code in an organizational box.</p> <pre><code>namespace math {\nint add(int x, int y) {\nreturn x + y;\n}\n}\n\nint sum = math::add(1,2);\n</code></pre> <p>This can prevent naming collisions, where two functions or variables have the same name. We can define an add function in the math name space, and in the normal namespace, and they will both be valid. Most libraries use at least one base namespace for this reason.</p> <p>Namespaces can be nested as much as you want. You have likely already seen the namespace for the standard library, std.</p> <pre><code>std::string hello = \"hello world\";\n</code></pre> <p>To save us some typing we can do:</p> <pre><code>using namespace std;\nstring hello = \"hello world\";\n</code></pre> <p>This brings everything from the std namespace into current scope, meaning we don't have to type out the namespace every time we want to use a function or variable from it. Note that this can now cause naming collisions because it includes everything from the entire namespace, meaning that if you have functions with the same name as things in the namespace you are including, your program will not compile.</p> <p>You can only include one namespace at a time.</p>"},{"location":"software/basics/oop/","title":"Object Oriented Programming","text":"<p>Simply put, object oriented programming is a way of organizing your code. It allows you to associate functions and variables with groups called objects.</p> <p>Objects are defined from classes. A class is like a blueprint. Imagine we have a class called Car. Car has properties, which are: color, speed, wheel_size. It might also have methods, like drive() and brake(). If we define a new car based on the Car class, it will have those properties and methods.</p> <p>Note</p> <p>Astute readers will notice that the capitalizations in the paragraph above are weird. This is because we always capitalize class names, but we never capitalize objects.</p>"},{"location":"software/basics/oop/#classes","title":"Classes","text":"<p>You can define a class as follows:</p> <pre><code>class Car {\npublic:\nint speed;\nColor color; // enum\nint wheelSize;\nvoid drive(); // you can define functions as a part of classes\n};\n\n// You can define a new object like this\nCar volvo;\n// Member variables are uninitialized by default\nvolvo.speed = 3;\nvolvo.color = Red;\nvolvo.wheelSize = 2\nvolvo.drive();\n</code></pre>"},{"location":"software/basics/oop/#class-members","title":"Class Members","text":"<p>Almost anything can be part of a class. Enums, functions, objects, and of course variables, can all be a part of a class.</p>"},{"location":"software/basics/oop/#public-vs-private","title":"Public vs Private","text":"<p>In our class definition, all of our members are public. This means that they can be accessed outside of the class. This is why we can assign values to the variables after the object is defined. Good practice is to only give public access to things that really need it. A good rule to follow is to make everything private by default, and then make things public as needed.</p> <p>There are other member categories, like protected and friend, but those will not be covered here.</p> <pre><code>class Car {\nprivate:\nint speed,\n};\n\nCar volvo;\nvolvo.speed = 3; // This will not work\n</code></pre>"},{"location":"software/basics/oop/#constructors","title":"Constructors","text":"<p>The way we had to assign values to members in the last chapter was pretty clunky. It required multiple lines, and all of the variables had to be public. However, there is a solution to this problem called constructors. Constructors are a special type of functions that return an instance of a class. They must have the same name as class.</p> <pre><code>class Car {\npublic:\nCar(int input) {\nspeed = input;\n}\nprivate:\nint speed;\n};\n\n// Now we can use our constructor like this:\nCar volvo(3);\n</code></pre>"},{"location":"software/basics/oop/#initializer-lists","title":"Initializer Lists","text":"<p>C++ provides even more shorthand for initializing variables. Initializer lists are a quick way to assign values to members of a class.</p> <pre><code>class Car {\npublic:\nCar();\nprivate:\nint speed;\nint wheelSize;\n};\n\nCar::Car(int speed, int wheelSize):\nspeed(speed),\nwheelSize(wheelSize),\n{\n// More complicated stuff should go here\n}\n</code></pre>"},{"location":"software/basics/operators/","title":"Operators","text":"<p>We\u2019ll go over operators in this section. I highly recommend checking out this link from cplusplus.com. It\u2019s very helpful for learning operators, and we\u2019ll be using some tables and examples from there.</p>"},{"location":"software/basics/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"Operator Description + addition - subtraction * multiplication / division % modulo <p>The addition, subtraction, multiplication, and division operators all do (for the most part) what you\u2019d think they\u2019d do. The modulo operator is a bit different though. It\u2019s also known as a remainder operator. It returns the remainder of division between two operands.</p> <p>Operand: An expression that an operator performs an action on.</p> <p>For example:</p> <ul> <li>11 % 5 = 1<ul> <li>11 / 5 = 2, with a remainder of 1</li> </ul> </li> <li>20 % 3 = 2<ul> <li>20 / 3 = 6, with a remainder of 2</li> </ul> </li> <li>3 % 5 = 3<ul> <li>3 / 5 = 0, with a remainder of 3</li> </ul> </li> </ul> <p>There\u2019s one more thing you need to know about how arithmetic operators work. They will only output a result with decimal points if a double or float is involved. For example:</p> <ul> <li>4 + 4 returns 8</li> <li> <p>4 + 4.0 returns 8.0</p> </li> <li> <p>21 / 4 returns 5 instead of 5.25</p> <ul> <li>Only integers are being provided.</li> </ul> </li> <li>21 / 4.0 returns 5.25</li> <li>A double is used in the expression, so the result will be a double.</li> </ul> Operator Description == Equal to != Not equal to &lt; Less than &gt; Greater than &lt;= Less than or equal to &gt;= Greater than or equal to <p>Comparison operators compare two operands and then return a boolean value (true/false). They\u2019re useful for conditional statements and loops, which we\u2019ll go into soon. They\u2019re fairly self explanatory, but here are some examples:</p> <pre><code>(7 == 5) // evaluates to false\n(5 &gt; 4)  // evaluates to true\n(3 != 2) // evaluates to true\n(6 &gt;= 6) // evaluates to true\n(5 &lt; 5)  // evaluates to false\n</code></pre> <p>You can also compare variables:</p> <pre><code>int a = 2;\n(a &gt; 1)  //evaluates to true\n</code></pre> <p>Note</p> <p>There is a HUGE difference between the = and == operators. The first one is used for assigning values to variables while the latter is used for comparing two operands with each other. Remember: One equal sign assigns, while two compare.</p>"},{"location":"software/basics/operators/#logical-operators","title":"Logical Operators","text":"<p>There are 3 logical operators:</p>"},{"location":"software/basics/operators/#-the-not-operator","title":"! - The Not Operator","text":"<p>Takes one boolean operand to its right and reverses its value (i.e. true \u2192 false, false \u2192 true)</p>"},{"location":"software/basics/operators/#examples","title":"Examples","text":"<pre><code>!false    //Evaluates to true\n!(5 == 5) //Evaluates to false\n!(5 &gt;= 2) //Evaluates to true\n</code></pre>"},{"location":"software/basics/operators/#-the-or-operator","title":"|| - The Or Operator","text":"<p>Takes 2 operands; one on the left and one on the right. Will return true if at least one operand evaluates to true and false otherwise.</p> a b a || b true true true true false true false true true false false false"},{"location":"software/basics/operators/#examples_1","title":"Examples","text":"<pre><code>(5 == 5) || (2 &lt; 0) //Evaluates to true\n(3 &gt; 3) || (2 == -1) //Evaluates to false\n(true || (10 &lt; 50) //Evaluates to true\n</code></pre>"},{"location":"software/basics/operators/#-the-and-operator","title":"&amp;&amp; - The And Operator","text":"<p>Takes 2 operands; one on the left and one on the right. Will return true if and only if both operands evaluate to true and false otherwise.</p>"},{"location":"software/basics/operators/#examples_2","title":"Examples","text":"<pre><code>(5 == 5) &amp;&amp; (2 &lt; 0)   //Evaluates to false\n(3 &gt; 3) | | (2 == -1) //Evaluates to false\ntrue | | (10 &lt; 50)    //Evaluates to true\n</code></pre>"},{"location":"software/basics/operators/#compound-operators","title":"Compound Operators","text":"Operator is equivalent to ... x += 5 x = x + 5 x -= 5 x = x - 5 x *= 5 x = x * 5 x /= 5 x = x / 5 <p>Compound operators combine the functions of the assignment operator and arithmetic operators. They offer a shortcut way to modify and set the value of a variable.</p>"},{"location":"software/basics/operators/#incremental-and-decremental-operators","title":"Incremental and Decremental Operators","text":"Operator is equivalent to ... x++ x = x + 1 x-- x = x - 1 <p>These are incremental and decremental operators. They\u2019re shortcuts similar to compound operators, but change a variable\u2019s value by increments of one. They\u2019re most commonly used in for loops, which we\u2019re going to cover soon!</p> <p>Note</p> <p>You must have a value assigned to a variable before you can use a compound, incremental, or decrement operator on it. This makes sense if you think about it; you can\u2019t perform arithmetic on undefined values</p>"},{"location":"software/basics/scope/","title":"Scope","text":"<p>Scope has to do when what is accessible where. This applies to everything that can be defined and declared, but is most relevant for variables.</p>"},{"location":"software/basics/scope/#variables","title":"Variables","text":"<p>All variables have a scope. This scope is layered. Variables from a higher scope can be accessed in a lower scope, but variables in a lower scope cannot be accessed in a higher scope, unless they are returned by a function. Scope is usually denoted by curly braces.</p> <pre><code>// Highest scope (Global)\nint main() {\n// Lower scope (Local)\n{\n// Lowest scope (Local)\n}\n}\n</code></pre>"},{"location":"software/basics/scope/#global-scope","title":"Global Scope","text":"<p>If a variable is in the highest scope, it is considered global, and is accessible everywhere in the file (unless it is externally linked).</p>"},{"location":"software/basics/scope/#abuse-of-global-scope","title":"Abuse of Global Scope","text":"<p>Global scope is very commonly abused. Just because functions can access variables in a higher scope then them, doesn't mean they should.</p> <pre><code>int x = 4;\nvoid blackBox() {\nx = 2; // This is possible, but never do it\n}\n</code></pre> <p>As a general rule, functions should work in a vacuum. They should be able to be copied and pasted into someone else's code by themselves, and compile.</p> <p>The reason for this is this: as your programs grow, it'll become harder and harder to keep track of what modifies what. Functions should only modify things in their scope. The only acceptable use of reading values outside of scope are constants. Constants are guaranteed to never change, so there's nothing to keep track of.</p> <pre><code>const float PI = 3.14; // Consts should be spelled with all caps\nfloat calculateWheelCircumference(float radius) {\nreturn 2 * radius * PI;\n}\n</code></pre>"},{"location":"software/basics/scope/#local-scope","title":"Local Scope","text":"<p>If a variable is defined inside of a function, it is considered to have local scope.</p>"},{"location":"software/basics/scope/#lifetimes","title":"Lifetimes","text":"<p>When a variable's local scope ends, the variables becomes \"killed\". The variable can no longer be referenced, and it's value is deallocated in memory.</p>"},{"location":"software/basics/scope/#shadowing","title":"Shadowing","text":"<p>A variable's value can be overridden in a lower scope. If a variable is redefined in a lower scope, the compiler will prioritize that definition over the one that already exists. Once the new definition leaves scope, the old one becomes used again.</p> <pre><code>int main() {\nint x = 1;\n{\nprintf(\"%i\\n\",x); // Will output 1.\nint x = 42;\nprintf(\"%i\\n\",x); // Will output 42.\n}\nprintf(\"%i\\n\",x); // Will output 1.\n}\n</code></pre>"},{"location":"software/basics/scope/#further-resources","title":"Further Resources","text":"<ul> <li>Introduction to local scope</li> <li>Introduction to global variables</li> <li>Why (non-const) global variables are evil</li> </ul>"},{"location":"software/basics/variables/","title":"Introduction to Variables","text":"<p>Storing and editing information are crucial in coding to help you to streamline your code and save important values that can be used when necessary. We do this through the use of variables.</p> <p>To create a variable, you need three main components:</p> <ul> <li>A data type</li> <li>A variable name</li> <li>A value to store</li> </ul> <p>Here\u2019s an example of creating a variable using these 3 components.</p> <ul> <li>Data type: int</li> <li>Variable name: meaningOfLife</li> <li>Value: 42</li> </ul> <pre><code>int meaningOfLife = 42;\n</code></pre>"},{"location":"software/basics/variables/#naming-a-variable","title":"Naming a Variable","text":"<p>You can use almost anything for a variable name. But, there are a few rules and conventions.</p> <ul> <li>The name can only begin with a letter or underscore.<ul> <li>Starting with anything else WILL give you an error!</li> <li>Numbers will work in a name after the first character though (so a variable called TheLegend27 would work fine)</li> </ul> </li> <li>Variable names are case sensitive<ul> <li>For example, variablename and VariableName are two different variables!     No special characters or spaces are allowed!</li> </ul> </li> <li>(note that underscores are an exception and can be used anywhere in a variable name)</li> <li>Keywords (predefined and reserved words in C++) cannot be used as variable names<ul> <li>For example, words such as try, switch, while, int, and if will not work. You\u2019ll get familiar with many of the different variables in C++ soon, and keywords in VEXCode will show up with a different color for easy identification.</li> </ul> </li> </ul>"},{"location":"software/basics/variables/#semicolons","title":"Semicolons","text":"<p>Real quickly, though, let\u2019s talk about semicolons. You need a semicolon at the end of every statement in your code excluding function headers and control structures (which we\u2019ll go over soon). You can think of them like punctuation but for coding. Just like you don\u2019t want to end a sentence without a period, you don\u2019t want to end a coding statement without a semicolon. As you can see below, the lack of a semicolon in the first statement gives you an error, so please, please, please don\u2019t forget to use semicolons.</p> <pre><code>//Valid\nint number = 42;\n\n//Invalid\nint number = 42\n</code></pre>"},{"location":"software/basics/variables/#datatypes","title":"Datatypes","text":"<p>There are 3 data types that you should familiarize yourself with. Data types define the type of value that a variable can hold. You only specify the data type of a variable when you create it, and the data type of a variable cannot be changed after it has been set.</p>"},{"location":"software/basics/variables/#integer-int","title":"Integer (int)","text":"<p>The integer data type is used when you need a variable that holds an integer number (one without any decimal points). You declare an integer variable by using the keyword int in front of the variable name. Here are some examples of integers:</p> <ul> <li>5</li> <li>0</li> <li>-532</li> </ul> <p>Here are some examples of numbers that aren\u2019t integers:</p> <ul> <li>5.0</li> <li>0.0</li> <li>-532.234</li> </ul> <p>Only use integer variables if you know that the values assigned to it will never have decimals, or else your code may not work the way you want it to. Integer variables are useful for counting and simple measurements where precision is not important.</p> <p>Example of creating an integer variable:</p> <pre><code>int number = 5;\n</code></pre>"},{"location":"software/basics/variables/#float-floatdouble-double","title":"Float (float)/Double (double)","text":"<p>The float and decimal data types are used when you need a variable that holds a decimal number (one with a decimal point). You declare a float variable by using the keyword float in front of the variable name, and a double variable by using the keyword double in front of the variable name. Here are some examples of decimals:</p> <ul> <li>4.0</li> <li>0.2</li> <li>-23.4</li> </ul> <p>Float and double variables are useful for when you need more precise measurements for your code, such as exact mathematical calculations and degree measurements. In this document we will use float for convenience\u2019s sake; you do NOT need to know the difference between a float and a double. Example of creating a float variable:</p> <pre><code>float number = 5.0;\n</code></pre> <p>Example of creating a double variable:</p> <pre><code>double number = 5.0;\n</code></pre> <p>Note</p> <p>If you are curious, though, double variables are more precise than float variables; able to store 64 bits of data instead of 32. We usually don\u2019t need the extra precision in robotics, so we tend to use float more than double.</p>"},{"location":"software/basics/variables/#boolean-bool","title":"Boolean (bool)","text":"<p>The boolean data type is used to store a boolean (true or false) value. You declare a boolean variable by using the keyword bool in front of the variable name. The two boolean values are true and false. A boolean variable can only store either one of these two values. Boolean variables are going to be particularly useful for control structures, which we'll go over in a different section.</p> <p>Example of creating a boolean variable:</p> <pre><code>bool atRest = false;\n</code></pre>"},{"location":"software/conventions/comments/","title":"Comments","text":"<p>This section is based off of this stack overflow blog post.</p> <p>Comments are a very useful and overused tool. Remember that no comment is better than a bad comment. You are guaranteed that the computer is doing exactly what you are telling it to, but there is no such guarantee for the comments. The comments can lie, but your code cannot.</p>"},{"location":"software/conventions/comments/#dont-write-redundant-comments","title":"Don't Write Redundant Comments","text":"<p>If what your code does is obvious, it doesn't need a comment.</p> <p>It is really easy to understand what this does, so it doesn't need a comment:</p> <pre><code>i = i + x; // Adds i to x\n</code></pre> <p>This is even worse:</p> <pre><code>// create a for loop // &lt;-- comment\nfor // start for loop\n(   // round bracket\n// newline\nint // type for declaration\ni    // name for declaration\n=   // assignment operator for declaration\n0   // start value for i\n</code></pre>"},{"location":"software/conventions/comments/#comments-do-not-excuse-unclear-code","title":"Comments do not Excuse Unclear Code","text":"<p>The most common culprit of unclear code are bad variable names</p> <pre><code>private static Node getBestChildNode(Node node) {\nNode n; // best child node candidate\nfor (Node node: node.getChildren()) {\n// update n if the current state is better\nif (n == null || utility(node) &gt; utility(n)) {\nn = node;\n}\n}\nreturn n;\n}\n\n// This doesn't need comments, because it explains itself\nprivate static Node getBestChildNode(Node node) {\nNode bestNode;\nfor (Node currentNode: node.getChildren()) {\nif (bestNode == null || utility(currentNode) &gt; utility(bestNode)) {\nbestNode = currentNode;\n}\n}\nreturn bestNode;\n}\n</code></pre> <p>Before resorting to writing comments, see if you can reword your code to make it more readable.</p>"},{"location":"software/conventions/comments/#if-you-cant-write-a-clear-comment-there-may-be-a-problem-with-the-code","title":"If You Can't Write a Clear Comment, There May be a Problem with the Code","text":"<p>Kerninghan's Law: Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.</p> <p>If your code cannot be described by a comment, you probably need to rewrite your code. If you are using obscure language features, or unclear, unintuitive syntax to make your program as short as possuble, consider rewriting your program.</p>"},{"location":"software/conventions/comments/#why-not-how","title":"Why, not How","text":"<p>While it might be obvious to you the reason you do things, other people might not. A good time to write comments is when it explains why you wrote something the way you did.</p> <pre><code>final Object value = (new JSONTokener(jsonString)).nextValue();\n// Note that JSONTokener.nextValue() may return\n// a value equals() to null.\nif (value == null || value.equals(null)) {\nreturn null;\n}\n</code></pre> <p>In this case it may not be obvious why the code handles a null case.</p>"},{"location":"software/conventions/comments/#links","title":"Links","text":"<p>If you used an outside source to figure out a peice of code, make sure to cite that source.</p> <pre><code>// Algorithm taken from:\n// http://thepilons.ca/wp-content/uploads/2018/10/Tracking.pdf\ndelta_x_global = (delta_y_local * cos(avg_theta_for_arc)) -\n(delta_x_local * sin(avg_theta_for_arc));\n\ndelta_y_global = (delta_y_local * sin(avg_theta_for_arc)) -\n(delta_x_local * cos(avg_theta_for_arc));\n</code></pre>"},{"location":"software/conventions/comments/#notes-to-self","title":"Notes to Self","text":"<p>If something is unimplemented, or not working, mark that with a comment. Annotations like FIXME and TODO are the standard way to do this. Most syntax highlighters will highlight these to make them pop out to people reading.</p> <pre><code>Coordinates getPosition() {\n// TODO: return the position of the robot in cartesian coordinates\n}\n</code></pre>"},{"location":"software/conventions/descriptive-variables/","title":"Descriptive Variables","text":"<p>Names communicate information. The more information you can communicate with your program, the better. This makes it clearer what the program is doing, not just to other people, but to you as well. Even if you think you will remember what a name means, you usually will not.</p> <p>In general, strive for descriptive variable and function names. Imagine that someone else is trying to read your code. Would they be more likely to understand a variable named <code>p</code>, or one named <code>motorPower</code>?</p>"},{"location":"software/conventions/descriptive-variables/#booleans","title":"Booleans","text":"<p>Boolean names should give a hint as to what their state means.</p> <pre><code>// Is true reversed, or is false reversed?\nbool reversed;\nbool isReversed; // Its clear that when this variable is true, something is reversed. But what?\nbool isNotReversed; // Never ever do this\n</code></pre>"},{"location":"software/conventions/descriptive-variables/#magic-numbers","title":"Magic Numbers","text":"<p>Never leave unlabeled numbers in your program.</p> <pre><code>// What is 2.75?\ndouble distTraveled = encoder.get_value() * (2 * M_PI * 2.75) / 360;\n\n// Better\nconst float WHEEL_RADIUS = 2.75;\ndouble distTraveled = encoder.get_value() * (2 * M_PI * WHEEL_RADIUS) / 360;\n\n// Even better\nconst float WHEEL_RADIUS = 2.75;\nconst float CIRCUMFERENCE =  2 * M_PI * WHEEL_RADIUS;\ndouble distTraveled = encoder.get_value() * CIRCUMFERENCE / 360;\n\n// Best\nconst float WHEEL_RADIUS = 2.75;\nconst float CIRCUMFERENCE =  2 * M_PI * WHEEL_RADIUS;\nconst float DIST_TRAVELED_PER_DEGREE =  CIRCUMFERENCE / 360;\ndouble distTraveled = encoder.get_value() * DIST_TRAVELED_PER_DEGREE;\n// This is maybe a little too explicit, but at least its very clear what's happening\n</code></pre>"},{"location":"software/conventions/introduction/","title":"Conventions","text":"<p>Coding conventions are general guidelines for creating clean, readable, structured, and interpretable code. While you can make a program following no coding conventions that works well, following some form of conventions can make mistakes less likely and collaboration much, much easier.</p>"},{"location":"software/conventions/naming-conventions/","title":"Naming Conventions","text":"<p>The capitalization of names communicates information as well. Whether something starts with a capital letter or a lowercase letter, or whether it uses snake_case, or camelCase, informs the reader of it's purpose.</p>"},{"location":"software/conventions/naming-conventions/#variable-names","title":"Variable Names","text":"<p>Variables use lower case camelCase. Many people use camelCase and snake_case interchangeably here. We recommend camelCase, but if you choose one, stick with it.</p> <pre><code>int MotorPower  // Incorrect\nint motorPower  // Correct\nint motor_power // Incorrect\n</code></pre>"},{"location":"software/conventions/naming-conventions/#constants","title":"Constants","text":"<p>Constants use SCREAMING_SNAKE_CASE. The reason constants are different from normal variables is because these a guaranteed to never change.</p> <pre><code>const float WHEEL_RADIUS = 2.75;\n</code></pre>"},{"location":"software/conventions/naming-conventions/#enums-structs-and-classes","title":"Enums, Structs and Classes","text":"<p>Enum, Struct and Class names all use UpperCamelCase.</p> <pre><code>enum Colors{};\nstruct Coordinates{};\nclass MotorEncoder{};\n</code></pre>"},{"location":"software/conventions/naming-conventions/#enum-members","title":"Enum Members","text":"<p>Enum members also use UpperCamelCase;</p> <pre><code>enum Colors {\nRed,\nGreen,\nBlue\n}\n</code></pre>"},{"location":"software/conventions/naming-conventions/#struct-and-class-members","title":"Struct and Class Members","text":"<p>These use camelCase.</p> <pre><code>class MotorEncoder {\npublic:\nfloat camelCase;\n};\n</code></pre>"},{"location":"software/conventions/program-organization/","title":"Program Structure","text":"<p>Program organization is a critical part of programming, that is very subjective. This of course means that no one can agree on how it should be done. However, there are a few general guidelines that you should follow.</p>"},{"location":"software/conventions/program-organization/#src-folder","title":"Src Folder","text":"<p>The src folder typically stores all of the body file in your project. It contains the entry point of your program, the main file.</p>"},{"location":"software/conventions/program-organization/#include-folder","title":"Include Folder","text":"<p>The include folder stores all of the header files in your project. </p>"},{"location":"software/conventions/program-organization/#header-file-structure","title":"Header File Structure","text":"<p>The organization of your header files typically mirrors that of the body files. There is typically one header file for each body file that you define. You only need to create headers for files that contain things that you want to access in other parts of your program. For example if I have a body file called utils.cpp, I would also create a file called utils.hpp. The folder structure of your headers should mirror the structure of your body files. For example if I have a folder called helpers, and in that folder I have auton.cpp, opcontrol.cpp, and misc.cpp, I would also create a folder for my headers called helpers, and in that folder I would create auton.hpp, opcontrol.hpp, and misc.hpp.</p>"},{"location":"software/git/branches/","title":"Branches","text":"<p>Branches allow you to create a fork in the timeline of your project.</p> <p></p> <p>A common use of branches is to create new features. This allows work to be done on another branch without interfering with the main branch. This is useful if you have multiple developers working together, and you don't want to break each other's work. Branches are also a very common way to have different releases, each with their own version.</p>"},{"location":"software/git/branches/#git-checkout","title":"Git Checkout","text":"<p>Git allows you to move between branches at will with the checkout command. Note that while making commits does not change your working directory, this will. Your code will be changed to the code in that branch.</p> <p>Warning</p> <p>You cannot change branches if your current uncommitted changes conflict with what is on the branch you are trying to switch to. If this happens, you can either commit your changes to your current branch, or or stash your changes. For more info, look here.</p>"},{"location":"software/git/commits/","title":"Commits","text":"<p>When you commit you create a set point in the history of your local repository. Together, the commits form a timeline of your project. When you commit, changes get moved from staging into your local repository as a commit. Keep in mind that this does not change your working directory in any way.</p> <p>Here is an example of a history with three commits:</p> <p></p> <p>Every commit has a commit message associated with it. This should summarize the changes made in that commit. Commits also have a hash. This is a unique identifier that is automatically generated whenever a commit is made.</p>"},{"location":"software/git/further-reading/","title":"Further Reading","text":"<ul> <li>Official Documentation.</li> <li>Using Git source control in VS Code</li> <li>Git Pro Book</li> </ul>"},{"location":"software/git/introduction/","title":"Git","text":""},{"location":"software/git/introduction/#what-is-git","title":"What is Git?","text":"<p>Git is a VCS or a version control system. It is used to save points in time on your code called commits. Together they make up the history of your project. The club uses git to manage our projects. We host our git projects on Github. You can find our Github organization, with code from past and current seasons here.</p>"},{"location":"software/git/introduction/#why-use-git","title":"Why use Git?","text":"<p>Git is a very powerful piece of software, with a lot of options. It is very manual, and doesn't do anything without the user specifying it. This makes it very difficult and unintuitive to use.</p> <p>Despite this, git is an extremely powerful tool. We use git for the following reasons:</p>"},{"location":"software/git/introduction/#collaboration","title":"Collaboration","text":"<p>Git makes it much easier to work together. You can combine it with Github in order to make code easily accessible. It's manual nature makes it so that changes don't get made to the code on your computer by other people without your consent. It also provides tools like branches and merging to make sure that your changes don't conflict.</p>"},{"location":"software/git/introduction/#safety","title":"Safety","text":"<p>Git allows you make changes without worrying about breaking your code. If you makes changes that you aren't happy with, you can simply revert to an older commit.</p>"},{"location":"software/git/introduction/#industry-standard","title":"Industry Standard","text":"<p>Git is used by everywhere where code is involved. This very guide is managed by git. You might as well learn it now.</p>"},{"location":"software/git/introduction/#goals-of-this-section","title":"Goals of this Section","text":"<p>There are may ways to use git, including:</p> <ul> <li>CLI (command line interface)</li> <li>Integrated VSCode support</li> <li>Integrated CLion support</li> <li>Github desktop</li> <li>Lazygit</li> </ul> <p>There is no way we can teach all of them, so this guide aims to be more conceptual, rather than practical, giving you a baseline to build off of. We will provide additional resources here.</p> <p>This section is inspired from this website.</p>"},{"location":"software/git/local-repo/","title":"Local Repositories","text":"<p>The local repository is stored on your computer. When you initialize a git project, a remote repository is created.</p> <p>Once a local repository is created, your development environment will look like this:</p> <p></p> <p>The working directory is simply the folder that your git project is created in. This is the base folder of your project, and contains all of your files. This is where you actually do work, and contains all of your code.</p> <p>Your staging area contains all of the changes you intend to commit.</p> <p>Your local repository contains your commits and branches.</p>"},{"location":"software/git/merging/","title":"Merging","text":"<p>Sometimes you want to get commits from one branch and bring them into another one, whether it be to bring in new features, or just get the latest code from the remote repository (we'll cover this later). Git provides a tool for this, merging.</p> <p></p> <p>Merging will create a new commit on the branch in which the merge is taking place. This commit is a combination of two commits, the latest ones from both branches.</p>"},{"location":"software/git/merging/#fast-forward","title":"Fast Forward","text":"<p>If a branch has not diverged from the one that you are merging into, git will resolve the issue via fast forward rather than a traditional merge.</p> <p></p> <p>This will add commits to the branch that is behind so that the history of the branches is up to date.</p>"},{"location":"software/git/merging/#rebasing","title":"Rebasing","text":"<p>Rebasing is another way to bring changes from one branch to another. This works a little differently from a merge. The result is the same, but they way they interact with history is different. A rebase will insert the commits of a branch backwards in time into the current one.</p> <p></p>"},{"location":"software/git/merging/#merging-vs-rebasing","title":"Merging vs Rebasing","text":"<p>This is a subject of debate among developers. The main source of contention is their effect on history. A rebase will go back in time and change history, while a merge will not. However, a rebase will leave you with a more accurate timeline of your project, showing more clearly what actually happened. Usually going back in time and changing history is frowned upon, hence the conflict.</p>"},{"location":"software/git/merging/#merge-conflicts","title":"Merge Conflicts","text":"<p>Sometimes merges cannot be resolved manually by git due to conflicting changes. When this occurs, merges will need to be resolved manually. This topic is rather complex, so it won't be covered here. You can find more about in in the further reading section.</p>"},{"location":"software/git/merging/#further-reading","title":"Further Reading","text":"<ul> <li>Basic Branching and Merging</li> <li>Advanced Merging</li> <li>Rebasing</li> <li>Git merge conflicts</li> </ul>"},{"location":"software/git/remote-repo/","title":"Remote Repositories","text":"<p>Remote repositories are they way that git enables collaboration between developers. Very commonly these remote repositories are hosted on Github, but it's possible to host your own as well, provided that you have your own server.</p> <p></p>"},{"location":"software/git/remote-repo/#acquiring-a-remote-repo","title":"Acquiring a Remote Repo","text":"<p>This can be done with clone. This will create a copy of that repository in a new directory on your computer. This only copy the code for the remote repository's current active branch, but it will create remote-tracking branches for the rest of the branches.</p>"},{"location":"software/git/remote-repo/#interacting-with-a-remote-repository","title":"Interacting with a Remote Repository","text":"<p>An important thing to remember is that a remote repo is not a direct mirror of the local ones. It will not automatically update as changes are made in local repositories. If you want to interact with the repo, you must do so manually and explicitly.</p>"},{"location":"software/git/remote-repo/#fetch","title":"Fetch","text":"<p>Fetching will grab all of the metadata from the remote repository, and update your local repository with it. This includes information on branches and commit history.</p> <p>Note</p> <p>Fetches are completely non-destructive, and therefore will never change your working directory. It is always safe to fetch.</p>"},{"location":"software/git/remote-repo/#pull","title":"Pull","text":"<p>Pulling will perform a fetch, but in addition it will also try to integrate the changes from the remote repository into the local one.</p> <p>Note</p> <p>A pull will only attempt to integrate into the current branch, not any others.</p> <p>If the history of the two branches (remote and local) is not divergent, the difference will simply be resolved by fast forwarding. If they are divergent, then a merge or a rebase will occur.</p> <p></p>"},{"location":"software/git/remote-repo/#push","title":"Push","text":"<p>A push will update the remote repository's metadata with the local one and send the matching objects along with it. If the local and remote repository conflict, the push will not succeed, and will throw an error. If this is the case, you will need to pull the changes from the remote repository to make the history match.</p> <p></p>"},{"location":"software/git/remote-repo/#further-reading","title":"Further Reading","text":"<ul> <li>Distributed Git - Contributing to a Project</li> </ul>"},{"location":"software/programming-the-bot/arcade-drive/","title":"Arcade Drive","text":"<p>This is another control scheme for controlling the drivetrain. With this, on joystick controls how fast the drivetrain move forwards and backwards, while the other controls the robot's turning.</p> <p>This control scheme may be more intuitive for beginner drivers, but is harder to program.</p> PROSVEXCode <pre><code>#include \"main.h\"\n\n// Motor definitions\npros::Motor_Group motors_left({1, 2, 3});\npros::Motor_Group motors_right({-4, -5, -6});\n\nvoid opcontrol() {\nwhile(1) {\n// Retrieve the necessary joystick values\nint leftY = master.get_analog(pros::E_E_CONTROLLER_ANALOG_LEFT_Y);\nint rightX = master.get_analog(pros::E_E_CONTROLLER_ANALOG_RIGHT_X);\n\n// Move the left side of the robot\nmotors_left.move(leftY + rightX);\n\n// Move the right side of the robot\nmotors_right.move(leftY - rightX);\ndelay(20);\n}\n}\n</code></pre> <pre><code>#include \"vex.h\"\nusing namespace vex;\n\nvex::motor left_motor(vex::PORT1);\nvex::motor right_motor(vex::PORT2);\n\nint main(void) {\nwhile(1) {\n// Retrieve the necessary joystick values\nint leftY = Controller1.Axis3.position(percent);\nint rightX = Controller1.Axis1.position(percent);\n\n// Move the left side of the robot\nmotors_left.spin(vex::directionType::fwd, leftY + rightX);\n\n// Move the right side of the robot \nmotors_right.spin(vex::directionType::fwd, leftY - rightX);\nwait(20, msec);\n}\n}\n</code></pre>"},{"location":"software/programming-the-bot/introduction/","title":"Programming the Robot","text":"<p>In order to interact with the VEX brain, you will need a library. There are two major ones:</p>"},{"location":"software/programming-the-bot/introduction/#vexcode","title":"VEXCode","text":"<p>This is an official library made by VEX. This is guaranteed to work for as long as VEX exists. This can be used either with it's own IDE (Integrated Development Environment, fancy word for code editor) called VEXCode Pro, or with Microsoft's VSCode.</p> <p>There is also a normal VEXCode IDE, which lets you code with blocks, similar to Scratch. However, if you use this, all programmers will instantly lose all respect for you.</p>"},{"location":"software/programming-the-bot/introduction/#installation","title":"Installation","text":"<p>VEXCode Pro:</p> <ul> <li>Download</li> </ul> <p>VSCode Extension:</p> <ul> <li>VSCode Download</li> <li>Extension</li> </ul>"},{"location":"software/programming-the-bot/introduction/#pros","title":"PROS","text":"<p>This is an unofficial library maintained by the students at Purdue University. It is somewhat harder to use, however it provides an experience close to what you would find in an actual C++ project. The documentation is much better written, and the library is much more powerful. It is open source, which means that development happens much faster, and that even you could contribute.</p> <p>PROS has a build in template manager, which has resulted in many libraries written for it, including:</p> <ul> <li>Sylib</li> <li>Ryanlib</li> <li>Okapilib</li> <li>ARMS</li> <li>LEGS</li> <li>EZ Template</li> </ul>"},{"location":"software/programming-the-bot/introduction/#installation_1","title":"Installation","text":"<p>It is recommended to use the VSCode extension to use PROS, but there is a CLI (command line interface) if you have a different editor that you prefer.</p> <ul> <li>Installation Instructions</li> </ul>"},{"location":"software/programming-the-bot/subsystem-toggling/","title":"Toggling Subsystems","text":"<p>This is a common pattern that you might want to use on subsystems. Often, subsystems will have an on or off state, and you might want to toggle between them with a single button press. This may be advantageous for the driver, because it means they don't need to hold down a button to enable something.</p> PROSVEXCode <pre><code>#include \"main.h\"\n\npros::Motor motor(1);\npros::Controller master();\npros::AdiDigitalOut piston();\n\nbool move = false; // by default, this will not move\nbool isPistonOn = false; // Piston starts retracted\n\nvoid opcontrol() {\nwhile(true) {\nif(master.get_digital_new_press(pros::Digital_B)) {\n// If this is true, move will changed to false\n// and vice versa. \nmove = !move; }\n\n// If move is true, move the motor.         \nif(move) {\nmotor.move(100);\n}\n// Else, don't\nelse {\nmotor.move(0);\n}\n\n\nif(master.get_digital_new_press(pros::Digital_A)) {\nisPistonOn = !isPistonOn; } piston.set_value(isPistonOn);\n\npros::delay(20);\n}\n}\n</code></pre> <pre><code>vex::motor mtr(vex::PORT1);\n\nvoid Motor_Move() {\nmtr.spin(vex::directionType::fwd, 100);\n}\n\nbool prev_value = false; bool move = false;\n\nint main() {\n// Since VEXCode doesn't have an equivalent function to \n// get_digital_new_press, we need to detect the new push \n// of a controller button. \nwhile (1) {\nprev_value = Controller1.ButtonB.pressing();\n// Detect a new press\nif(prev_value == false &amp;&amp; Controller1.ButtonB.pressing()) {\nmove = !move;\n}\n\nif(move) {\nmtr.spin(vex::directionType::fwd, 100);\n}\nelse {\nmtr.spin(vex::directionType::fwd, 0);\n}\nwait(20, msec);\n}\n// OR\n\n// Alternatively, VEXCode also supports \n// callbacks bound to controller buttons\n//\n// DO NOT put this in a while loop, call before a\n// while loop unlike this example. \nController1.ButtonB.pressed( Motor_Move );\n}\n</code></pre>"},{"location":"software/programming-the-bot/tank-drive/","title":"Tank Drive","text":"<p>Tank drive is a control scheme for controlling the drivetrain. With this, the controller's left joystick controls the left side of the robot, while the right joystick controls the right side of the robot.</p> <p>This control scheme is very easy to code, but can be unintuitive for an inexperienced driver. Some drivers prefer this control scheme due to it's increased level of control.</p> PROSVEXCode <pre><code>#include \"main.h\"\n\n// Motor Group Declarations for Left and Right\npros::Motor_Group motors_left({1,2,3});\npros::Motor_Group motors_right({-4,-5,-6}); // Negative ports indicate reversed motors\n\nvoid opcontrol() {\nwhile(1) {\n// Drive the left side of the robot forward at joystick left Y speed\nmotors_left.move(master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y));\n\n// Drive the right side of the robot forward at joystick right Y speed\nmotors_right.move(master.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_Y));\ndelay(20);\n}\n}\n</code></pre> <pre><code>#include \"vex.h\"\nusing namespace vex;\n\nvex::motor left_motor(vex::PORT1);\nvex::motor right_motor(vex::PORT2, true);\n\nint main(void) {\nwhile(1) {\n// Retrieve the necessary joystick values\nint leftY = Controller1.Axis3.position(percent);\nint rightY = Controller1.Axis2.position(percent);\n\n// Move the left side of the robot\nmotors_left.spin(vex::directionType::fwd, leftY);\n\n// Move the right side of the robot\nmotors_right.spin(vex::directionType::fwd, rightY);\nwait(20, msec);\n}\n}\n</code></pre>"}]}